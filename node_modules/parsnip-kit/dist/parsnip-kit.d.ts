export declare function camelCase(arg: string): string

export declare function kebabCase(arg: string): string

export declare function pascalCase(arg: string): string

export declare function snakeCase(arg: string): string

export declare function splitToWords(arg: string): string[]

export declare function splitToKeys(arg: string): string[]

export declare function upperSnakeCase(arg: string): string

export declare function capitalize(arg: string): string

export declare function titleCase(arg: string): string

export declare function htmlEncode(arg: string): string

export declare function htmlDecode(arg: string): string

export declare function escapeRegExp(str: string): string

export type PrimitiveType =
  | undefined
  | null
  | number
  | string
  | boolean
  | bigint
  | symbol

export type NumberString = `${number}`

export type PseudoArray = object & {
  length: number
}

export type ObjectLike = object & {
  call?: never
  [x: PropertyKey]: any
}

export type ExtractUnion<T extends readonly string[]> = {
  [K in keyof T]: T[K]
}[number]

export type KeyOrIndex<T extends string> = T extends
  | `[${infer D extends number}]`
  | `${infer D extends number}`
  ? D
  : T

export type Tail<T extends readonly any[]> = T extends readonly [
  ...any[],
  infer L
]
  ? L
  : never

export type Head<T extends readonly any[]> = T extends readonly [
  infer L,
  ...any[]
]
  ? L
  : never

export type Edge<
  T extends readonly any[],
  D = 'left' | 'right'
> = D extends 'left' ? Head<T> : Tail<T>

export type EdgeReverse<
  T extends readonly any[],
  D = 'left' | 'right'
> = D extends 'right' ? Head<T> : Tail<T>

export type EmptyOrParameters<T> = T extends (...args: any[]) => any
  ? Parameters<T>
  : never[]

export type EmptyOrReturnType<T> = T extends (...args: any[]) => any
  ? ReturnType<T>
  : void

export type WithFallback<T extends (...args: any[]) => any, R> =
  ReturnType<T> extends undefined | null ? R : ReturnType<T>

export type LiteralStringWithFallback<T extends string, R extends string> = T &
  R extends never
  ? T
  : R

export type MappedTypeByKeyOrIndex<
  T extends string,
  V,
  O extends boolean = false
> =
  KeyOrIndex<T> extends string
    ? O extends false
      ? {
          [P in T]: V
        }
      : {
          [P in T]?: V
        }
    : O extends false
      ? unknown[] & {
          [P in KeyOrIndex<T>]: V
        }
      : unknown[] & {
          [P in KeyOrIndex<T>]?: V
        }

export type DeepMappedTypeByKeyOrIndex<
  T extends string,
  V,
  O extends boolean = false
> = T extends `[${infer Key extends number}][${infer Rest}`
  ? MappedTypeByKeyOrIndex<`${Key}`, DeepMappedTypeByKeyOrIndex<`[${Rest}`, V>>
  : T extends `${infer Key}[${infer Rest}`
    ? MappedTypeByKeyOrIndex<
        `${Key}`,
        DeepMappedTypeByKeyOrIndex<`[${Rest}`, V>
      >
    : T extends `[${infer Key extends number}].${infer Rest}`
      ? MappedTypeByKeyOrIndex<`${Key}`, DeepMappedTypeByKeyOrIndex<Rest, V>>
      : T extends `${infer Key}.${infer Rest}`
        ? MappedTypeByKeyOrIndex<`${Key}`, DeepMappedTypeByKeyOrIndex<Rest, V>>
        : MappedTypeByKeyOrIndex<T, V, O>

export type DataUnit =
  | 'bit'
  | 'B'
  | 'KB'
  | 'MB'
  | 'GB'
  | 'TB'
  | 'PB'
  | 'EB'
  | 'ZB'
  | 'YB'

export type Nullish = undefined | null

export type SpreadSkipNullish<T, U> = {
  [K in keyof T | keyof U]: K extends keyof T
    ? K extends keyof U
      ? T[K] extends Nullish
        ? U[K]
        : U[K] extends Nullish
          ? T[K]
          : U[K]
      : T[K]
    : K extends keyof U
      ? U[K]
      : never
}

export type IsAny<T> = 0 extends 1 & T ? true : false

export type ArrayIndexes<T extends any[]> = Exclude<
  keyof T,
  keyof any[] | 'length'
> &
  (string | number)

export type FieldPathComponent<
  Str extends string | number,
  Next extends 'object' | 'array' | void = void
> = Str extends NumberString | number
  ? Next extends 'object'
    ? `[${Str & (string | number)}].`
    : `[${Str & (string | number)}]`
  : Next extends 'object'
    ? `${Str & string}.`
    : `${Str & string}`

export type FlattenArrayObject<
  T extends Array<any>,
  Prefix extends string = ''
> = {
  [K in number | ArrayIndexes<T>]: IsAny<T[K]> extends true
    ? {
        [P in `${Prefix}${FieldPathComponent<K>}`]: T[K]
      }
    : T[K] extends never
      ? never
      : T[K] extends object
        ? T[K] extends Array<any>
          ? FlattenArrayObject<
              T[K],
              `${Prefix}${FieldPathComponent<K, 'array'>}`
            >
          : FlattenObject<T[K], `${Prefix}${FieldPathComponent<K, 'object'>}`>
        : {
            [P in `${Prefix}${FieldPathComponent<K>}`]: T[K]
          }
}[ArrayIndexes<T> | number]

export type FlattenObject<T, Prefix extends string = ''> = {
  [K in keyof T & string]: IsAny<T[K]> extends true
    ? {
        [P in `${Prefix}${FieldPathComponent<K>}`]: T[K]
      }
    : T[K] extends never
      ? never
      : T[K] extends object
        ? T[K] extends Array<any>
          ? FlattenArrayObject<
              T[K],
              `${Prefix}${FieldPathComponent<K, 'array'>}`
            >
          : FlattenObject<T[K], `${Prefix}${FieldPathComponent<K, 'object'>}`>
        : {
            [P in `${Prefix}${FieldPathComponent<K>}`]: T[K]
          }
}[keyof T & string]

export type UnionToIntersection<U> = (
  U extends any ? (x: U) => any : never
) extends (x: infer R) => any
  ? R
  : never

export type IntersectionToObject<U> = {
  [K in keyof UnionToIntersection<U>]: UnionToIntersection<U>[K]
}

export type FlattenNestObject<T extends object> = IntersectionToObject<
  UnionToIntersection<FlattenObject<T>>
>

export declare function parseTemplate(
  template: string,
  parser: ObjectLike | ((pattern: string) => string | undefined | null),
  options?: {
    start?: string
    end?: string
  }
): string

export declare function isString(arg: any): arg is string

export declare function isBoolean(arg: any): arg is boolean

export declare function isNull(arg: any): arg is null

export declare function isNumber(arg: any): arg is number

export declare function isObject(arg: any): arg is object

export declare function isUndefined(arg: any): arg is undefined

export declare function isSymbol(arg: any): arg is symbol

export declare function isBigInt(arg: any): arg is bigint

export declare function isPrimitive(arg: any): arg is PrimitiveType

export declare function isNumberString(arg: any): arg is NumberString

export declare function isArray(arg: any): arg is any[]

export declare function isFunction(arg: any): arg is Function

export declare function isObjectLike(arg: any): arg is ObjectLike

export declare function isClass(arg: any): arg is Function

export declare function isPseudoArray(arg: any): arg is PseudoArray

export declare function isInfinity(arg: any): boolean

export declare function isNanValue(arg: any): boolean

export declare function isInt(arg: any): boolean

export declare function isFloat(arg: any): boolean

export declare const getTypeTag: (arg: any) => string

export declare function isNullish(arg: any): arg is Nullish

export declare function getByPath(
  obj: object,
  path: string,
  defaultValue?: any
): any

export declare function setByPath(obj: object, path: string, value: any): void

export declare function deleteByPath(obj: object, path: string): void

export declare function clone<T extends PrimitiveType | ObjectLike>(arg: T): T

export declare function cloneDeep<T>(arg: T, customizeClone?: CustomizeClone): T

export type CustomizeClone = (
  arg: any,
  key: string | undefined,
  cache: WeakMap<any, any>,
  defaultClone4Object: (
    arg: ObjectLike,
    cache: WeakMap<any, any>,
    customizeClone?: CustomizeClone
  ) => any
) => any

export declare function omit<T extends object, R extends readonly string[]>(
  obj: T,
  keys: R
): Omit<T, KeyOrIndex<ExtractUnion<R>>>

export declare function pick<T extends object, R extends readonly string[]>(
  obj: T,
  keys: R
): Pick<T, KeyOrIndex<ExtractUnion<R>> & keyof T>

export declare function filterFields<T extends object>(
  obj: T,
  iterator: (value: any, key: string, object: T) => boolean
): object

export declare function forEachFields<T extends object>(
  obj: T,
  iterator: (value: any, key: string, object: T) => any
): void

export declare function isEqual(arg1: any, arg2: any): boolean

export declare function isEqualStrict(arg1: any, arg2: any): boolean

export declare function unzipToArrays<T extends object>(
  obj: T,
  createKey?: (value: T[string & keyof T], key: string, obj: T) => any,
  createValue?: (value: T[string & keyof T], key: string, obj: T) => any
): [string[], T[keyof T][]]

export declare function objectToPairs<T extends object>(
  obj: T,
  createItem?: (value: T[string & keyof T], key: string, obj: T) => any
): any

export declare function splitToArrays<T extends object>(
  obj: T,
  createItem?: (value: T[string & keyof T], key: string, obj: T) => any
): [string, T[keyof T]][]

export declare function mergeSkipNullish<T extends object, U extends object>(
  a: T | Nullish,
  b: U | Nullish
): SpreadSkipNullish$1<T, U>
export declare function mergeSkipNullish<
  T extends object,
  U extends object,
  V extends object
>(
  a: T | Nullish,
  b: U | Nullish,
  c: V | Nullish
): SpreadSkipNullish$1<SpreadSkipNullish$1<T, U>, V>
export declare function mergeSkipNullish<
  T extends object,
  U extends object,
  V extends object,
  W extends object
>(
  a: T | Nullish,
  b: U | Nullish,
  c: V | Nullish,
  d: W | Nullish
): SpreadSkipNullish$1<SpreadSkipNullish$1<SpreadSkipNullish$1<T, U>, V>, W>
export declare function mergeSkipNullish(...objs: any[]): any
type SpreadSkipNullish$1<T, U> = {
  [K in keyof T | keyof U]: K extends keyof T
    ? K extends keyof U
      ? T[K] extends Nullish
        ? U[K]
        : U[K] extends Nullish
          ? T[K]
          : U[K]
      : T[K]
    : K extends keyof U
      ? U[K]
      : never
}

export declare function flattenObject<T extends object>(
  obj: T
): FlattenNestObject<T>

export declare function difference<T>(
  arr1: T[],
  arr2: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): T[]

export declare function intersection<T>(
  arr1: T[],
  arr2: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): T[]

export declare function union<T>(
  arr1: T[],
  arr2: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): T[]

export declare function symmetricDifference<T>(
  arr1: T[],
  arr2: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): T[]

export declare function unique<T>(
  arr: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): T[]

export declare function leftJoin<
  T extends object,
  U extends object,
  R extends object
>(
  left: T[],
  right: U[],
  leftKey: string | ((item: T, index: number, arr: T[]) => any),
  rightKey: string | ((item: U, index: number, arr: U[]) => any),
  merge: (left: T, right: U | undefined) => R
): R[]

export declare function sortIndex<T>(
  arr: T[],
  comparator?: (a: T, b: T) => number
): number[]

export declare function joinToObject<T extends object>(
  fields: T[],
  getKey?: string | ((item: T, index: number, arr: T[]) => any),
  getValue?: string | ((item: T, index: number, arr: T[]) => any)
): ObjectLike

export declare function pairsToObject<T extends object>(
  pairs: T[],
  getKey?: string | ((item: T, index: number, arr: T[]) => any),
  getValue?: string | ((item: T, index: number, arr: T[]) => any)
): ObjectLike

export declare function zipToObject<T, U>(
  keys: T[],
  values: U[],
  getKey?: string | ((item: T, index: number, arr: T[]) => any),
  getValue?: string | ((item: U, index: number, arr: U[]) => any)
): ObjectLike

export declare function sortWithIndex<T>(
  arr: T[],
  comparator?: (a: T, b: T) => number
): number[]

export declare function lexSort<T, R extends 'asc' | 'desc' = 'asc' | 'desc'>(
  arr: T[],
  order?: R,
  getter?: string | ((item: T) => string)
): T[]

export declare function linkToTree<T extends object, R extends string>(
  arr: T[],
  getKey?: string | ((item: T, index: number, arr: T[]) => string),
  getParent?: string | ((item: T, index: number, arr: T[]) => string),
  childrenPath?: R
): (T &
  DeepMappedTypeByKeyOrIndex<
    LiteralStringWithFallback<R, 'children'>,
    T[],
    false
  >)[]

export declare function chunk<T>(arr: T[], length: number): T[][]

export declare function numberSort<
  T,
  R extends 'asc' | 'desc' = 'asc' | 'desc'
>(arr: T[], order?: R, getter?: string | ((item: T) => number)): T[]

export declare function orderSort<T>(
  arr: T[],
  order: any[],
  getter?: string | ((item: T) => any)
): T[]

export declare function range(
  start: number,
  end: number,
  step?: number
): number[]

export declare function percent(
  num: number,
  total?: number,
  fixed?: number
): string

export declare function thousandSeparator(num: number): string

export declare function convertDataUnit(
  value: number,
  from: DataUnit,
  to: DataUnit,
  prefix?: 'binary' | 'decimal'
): number

export declare function average<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => number)
): number

export declare function count<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): Map<any, number>

export declare function median<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => number)
): number

export declare function mode<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): any

export declare function sum<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => number)
): number

export declare function max<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => number)
): number

export declare function maxItem<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => number)
): T

export declare function min<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => number)
): number

export declare function minItem<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => number)
): T

export declare function modeItem<T>(
  data: T[],
  getter?: string | ((item: T, index: number, arr: T[]) => any)
): T

export declare function randomBoolean(): boolean

export declare function randomFromArray<T>(arr: T[]): T

export declare function randomNumber(start?: number, end?: number): number

export declare function randomString(
  length: number,
  options?: RandomStringOptions
): string

export interface RandomStringOptions {
  lowercase?: boolean
  uppercase?: boolean
  number?: boolean
  symbol?: boolean
  customized?: string
}

export declare function randomInt(start?: number, end?: number): number

export declare function combine<
  T extends readonly ((...args: any[]) => any)[],
  R extends 'left' | 'right' = 'left' | 'right'
>(
  functions: T,
  direction?: R
): (
  ...args: EmptyOrParameters<Edge<T, R>>
) => EmptyOrReturnType<EdgeReverse<T, R>>

export declare function curry(
  fn: (...args: any[]) => any
): (this: any, ...args: any[]) => any

export declare function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number,
  options?: {
    maxWait?: number
    immediate?: boolean
  }
): (...args: Parameters<T>) => void

export declare function delay<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (this: ThisParameterType<T>, ...args: Parameters<T>) => void

export declare function memoize<T extends (...args: any[]) => any>(
  func: T,
  resolver?: (...args: Parameters<T>) => any,
  initCache?: Parameters<T>
): (this: any, ...args: Parameters<T>) => ReturnType<T>

export declare function throttle<T extends (...args: any[]) => any>(
  func: T,
  wait: number,
  options?: {
    leading?: boolean
    trailing?: boolean
  }
): (this: ThisParameterType<T>, ...args: Parameters<T>) => void

export declare function once<T extends (...args: any[]) => any>(
  func: T
): (this: ThisParameterType<T>, ...args: Parameters<T>) => ReturnType<T>

export declare function withFallback<T extends (...args: any[]) => any, R>(
  func: T,
  defaultValue: R
): (this: ThisParameterType<T>, ...args: Parameters<T>) => WithFallback<T, R>

export declare function go<T, U = any>(
  func: (...x: any[]) => T
): Promise<[Awaited<T>, null] | [null, U]>

export declare function asyncForEach<
  T,
  R extends 'concurrent' | 'sequential' = 'concurrent' | 'sequential'
>(
  array: T[],
  iterator: (item: T, index: number, array: T[]) => any,
  concurrent?: R
): Promise<void>

export declare function asyncForEachFields<
  T extends object,
  R extends 'concurrent' | 'sequential' = 'concurrent' | 'sequential'
>(
  obj: T,
  iterator: (value: any, key: string, object: T) => any,
  concurrent?: R
): Promise<void>

export declare function asyncMap<
  T,
  U,
  R extends 'concurrent' | 'sequential' = 'concurrent' | 'sequential'
>(
  array: T[],
  iterator: (item: T, index: number, array: T[]) => U | Promise<U>,
  concurrent?: R
): Promise<U[]>

export declare function concurrent<T>(
  functions: (() => Promise<T>)[],
  limit: number
): Promise<PromiseSettledResult<Awaited<T>>[]>

export declare function sequential<T>(
  functions: ((arg?: PromiseSettledResult<Awaited<T>>) => Promise<T>)[],
  initialValue?: Awaited<T>
): Promise<PromiseSettledResult<Awaited<T>>[]>

export declare function retry<T>(
  func: (...args: any[]) => Promise<T>,
  maxRetries?: number,
  options?: RetryOptions<T>
): (
  this: unknown,
  ...args: Parameters<typeof func>
) => Promise<PromiseSettledResult<Awaited<T>>>

export interface RetryOptions<T> {
  delay?: number
  delayFactor?: number
  shouldRetry?: (error: any, attempts: number) => boolean
  onSuccess?: (result: T, attempts: number) => void
  onFailure?: (error: any, attempts: number) => void
}

export declare function poll<T>(
  func: (...args: any[]) => Promise<T>,
  wait: number,
  options?: PollOptions<T>
): (this: unknown, ...args: Parameters<typeof func>) => PollResult

export interface PollOptions<T> {
  maxRetries?: number
  sequential?: boolean
  leading?: boolean
  maxCalls?: number
  onSuccess?: (result: T, retries: number) => void
  onFailure?: (error: any, retries: number) => void
}

export interface PollResult {
  stop: () => void
  start: () => void
  isRunning: () => boolean
}

export declare const stringComparatorAsc: (a: string, b: string) => number

export declare const stringComparatorDesc: (a: string, b: string) => number

export declare const numberComparatorAsc: (a: number, b: number) => number

export declare const numberComparatorDesc: (a: number, b: number) => number

export declare const codeUnitComparatorAsc: (a: string, b: string) => 0 | 1 | -1

export declare const codeUnitComparatorDesc: (
  a: string,
  b: string
) => 0 | 1 | -1

export {}
