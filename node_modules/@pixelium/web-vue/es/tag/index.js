import './css.js'
import { defineComponent, createElementBlock, openBlock, normalizeStyle, createElementVNode, ref, shallowRef, onMounted, nextTick, computed, watch, normalizeClass, renderSlot, createCommentVNode, createVNode, unref } from "vue";
import { a as canvasPreprocess, c as calcPixelSize, g as getBorderRadius, b as calcBorderCornerCenter, f as floodFill } from "../share/util/plot.js";
import { p as parseColor, a as generatePalette } from "../share/util/color.js";
import { g as getTextColorWithPalette, a as getBorderColor, d as drawBorder, b as getBackgroundColor } from "./draw.js";
import { u as useDarkMode } from "../share/hook/use-dark-mode.js";
import { u as useResizeObserver } from "../share/hook/use-resize-observer.js";
import { u as useWatchGlobalCssVal } from "../share/hook/use-watch-global-css-var.js";
import { B as BORDER_CORNER_RAD_RANGE } from "../share/const/index.js";
const Times = /* @__PURE__ */ defineComponent({
  props: {
    size: {},
    color: {}
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "svg",
        {
          class: "px-icon-hn",
          style: normalizeStyle({ color: props.color, fontSize: props.size + "px" }),
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24"
        },
        [..._cache[0] || (_cache[0] = [
          createElementVNode(
            "path",
            { d: "M14 13h1v1h1v1h1v1h1v1h1v1h1v1h1v1h1v1h-1v1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-2v1h-1v1H9v1H8v1H7v1H6v1H5v1H4v1H3v-1H2v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-2H9v-1H8V9H7V8H6V7H5V6H4V5H3V4H2V3h1V2h1v1h1v1h1v1h1v1h1v1h1v1h1v1h1v1h2V9h1V8h1V7h1V6h1V5h1V4h1V3h1V2h1v1h1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1z" },
            null,
            -1
            /* CACHED */
          )
        ])],
        4
        /* STYLE */
      );
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "px-tag-icon-wrapper"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "Tag"
  },
  __name: "index",
  props: {
    borderRadius: null,
    shape: { default: "default" },
    size: { default: "medium" },
    disabled: { type: Boolean, default: false },
    variant: { default: "primary" },
    theme: { default: "primary" },
    color: null,
    closable: { type: Boolean }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const closeHoverFlag = ref(false);
    const closeActiveFlag = ref(false);
    const toggleHover = (value) => {
      closeHoverFlag.value = value;
    };
    const toggleActive = (value) => {
      closeActiveFlag.value = value;
    };
    const darkMode = useDarkMode();
    const canvasRef = shallowRef(null);
    const tagRef = shallowRef(null);
    onMounted(() => {
      nextTick(() => {
        drawPixel();
      });
    });
    const palette = computed(() => {
      if (!props.color) return null;
      const color = parseColor(props.color);
      const palette2 = generatePalette(color.r, color.g, color.b, color.a, darkMode.value);
      return palette2;
    });
    const textColor = computed(() => {
      return getTextColorWithPalette(palette.value, props.variant, props.disabled);
    });
    const closeHandler = (e) => {
      if (!props.disabled) {
        emits("close", e);
      }
    };
    watch(
      [
        () => props.borderRadius,
        () => props.shape,
        () => props.disabled,
        () => props.variant,
        () => props.theme,
        palette,
        darkMode
      ],
      () => {
        drawPixel();
      }
    );
    const drawPixel = () => {
      const preprocessData = canvasPreprocess(tagRef, canvasRef);
      if (!preprocessData) {
        return;
      }
      const { ctx, width, height, canvas } = preprocessData;
      const pixelSize = calcPixelSize();
      const borderRadius = getBorderRadius(
        canvas,
        pixelSize,
        props.borderRadius,
        props.shape,
        "medium",
        false,
        false,
        false
      );
      const borderColor = getBorderColor(props.disabled, props.variant, props.theme, palette.value);
      const center = calcBorderCornerCenter(borderRadius, width, height, pixelSize);
      const rad = BORDER_CORNER_RAD_RANGE;
      drawBorder(ctx, width, height, center, borderRadius, rad, borderColor, pixelSize);
      const backgroundColor = getBackgroundColor(
        props.disabled,
        props.variant,
        props.theme,
        palette.value
      );
      floodFill(ctx, Math.round(width / 2), Math.round(height / 2), backgroundColor);
    };
    useResizeObserver(tagRef, drawPixel);
    useWatchGlobalCssVal(drawPixel);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "span",
        {
          class: normalizeClass(["pixelium px-tag", {
            "px-tag__large": props.size === "large",
            "px-tag__small": props.size === "small",
            "px-tag__outline": props.variant === "outline",
            "px-tag__plain": props.variant === "plain",
            "px-tag__disabled": props.disabled,
            "px-tag__custom": palette.value,
            [`px-tag__${props.theme || "primary"}`]: true
          }]),
          style: normalizeStyle({
            color: textColor.value
          }),
          ref_key: "tagRef",
          ref: tagRef
        },
        [
          createElementVNode(
            "canvas",
            {
              ref_key: "canvasRef",
              ref: canvasRef,
              class: "px-tag-canvas"
            },
            null,
            512
            /* NEED_PATCH */
          ),
          renderSlot(_ctx.$slots, "default"),
          props.closable ? (openBlock(), createElementBlock("div", _hoisted_1, [
            createVNode(unref(Times), {
              onMousedown: _cache[0] || (_cache[0] = ($event) => toggleActive(true)),
              onMouseup: _cache[1] || (_cache[1] = ($event) => toggleActive(false)),
              onMouseenter: _cache[2] || (_cache[2] = ($event) => toggleHover(true)),
              onMouseleave: _cache[3] || (_cache[3] = ($event) => toggleHover(false)),
              onClick: closeHandler,
              class: "px-tag-icon",
              style: normalizeStyle({
                fill: textColor.value
              })
            }, null, 8, ["style"])
          ])) : createCommentVNode("v-if", true)
        ],
        6
        /* CLASS, STYLE */
      );
    };
  }
});
export {
  _sfc_main as _
};
