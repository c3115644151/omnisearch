import './css.js'
import { defineComponent, computed, getCurrentInstance, ref, inject, createElementBlock, openBlock, normalizeStyle, normalizeClass, unref, renderSlot } from "vue";
import { k } from "../aside/index.js";
import { u as useScreenWidth } from "../share/hook/use-screen-width.js";
import { _ as _sfc_main$1 } from "../row/index.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "Col"
  },
  __name: "index",
  props: {
    offset: { default: 0 },
    span: { default: 24 }
  },
  setup(__props) {
    var _a;
    const props = __props;
    const [widthType] = useScreenWidth();
    const offsetComputed = computed(() => {
      if (k(props.offset)) {
        return props.offset;
      }
      return props.offset[widthType.value] || 0;
    });
    const spanComputed = computed(() => {
      if (k(props.span)) {
        return props.span;
      }
      return props.span[widthType.value] || 24;
    });
    const instance = getCurrentInstance();
    const inner = ref(((_a = instance == null ? void 0 : instance.parent) == null ? void 0 : _a.type) === _sfc_main$1);
    const gutter = inner.value && inject("px-row-provide") || ref({ x: 0, y: 0 });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(["pixelium px-col", {
            [`px-col__span-${spanComputed.value}`]: true,
            [`px-col__offset-${offsetComputed.value}`]: true
          }]),
          style: normalizeStyle({
            paddingLeft: unref(gutter) ? unref(gutter).x / 2 + "px" : void 0,
            paddingRight: unref(gutter) ? unref(gutter).x / 2 + "px" : void 0,
            paddingTop: unref(gutter) ? unref(gutter).y / 2 + "px" : void 0,
            paddingBottom: unref(gutter) ? unref(gutter).y / 2 + "px" : void 0
          })
        },
        [
          renderSlot(_ctx.$slots, "default")
        ],
        6
        /* CLASS, STYLE */
      );
    };
  }
});
export {
  _sfc_main as _
};
