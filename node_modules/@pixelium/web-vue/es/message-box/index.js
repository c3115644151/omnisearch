var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { ref, createVNode, render, nextTick } from "vue";
import { _ as _sfc_main } from "./message-box.js";
import { p, m } from "../aside/index.js";
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};
class MessageManager {
  constructor(options) {
    __publicField(this, "messages");
    __publicField(this, "messageBox");
    __publicField(this, "container", null);
    this.messages = ref([]);
    this.messageBox = createVNode(_sfc_main, {
      messages: this.messages.value,
      placement: options.placement,
      onClose: (id2) => {
        const idx = this.messages.value.findIndex((e) => e.id === id2);
        if (idx >= 0) {
          this.messages.value.splice(idx, 1);
        }
      }
    });
    const root = (p(options.root) ? document.querySelector(options.root) : options.root) || document.body;
    const id = nanoid();
    this.container = document.createElement("div");
    this.container.id = id;
    this.container.className = `px-message-box-wrapper`;
    root.appendChild(this.container);
    render(this.messageBox, this.container);
  }
  push(options) {
    const id = options.id ?? nanoid();
    this.messages.value.push({
      ...options,
      id
    });
    return id;
  }
  close(id) {
    var _a, _b;
    (_b = (_a = this.messageBox.component) == null ? void 0 : _a.exposed) == null ? void 0 : _b.close(id);
  }
  clear() {
    this.messages.value.length = 0;
  }
  unmount() {
    if (this.container) {
      const container = this.container;
      render(this.messageBox, container);
      nextTick(() => {
        container.remove();
        this.container = null;
      });
    }
  }
}
const messageManagers = {
  top: void 0,
  bottom: void 0,
  "top-left": void 0,
  "top-right": void 0,
  "bottom-left": void 0,
  "bottom-right": void 0
};
const messageCall = (options) => {
  if (p(options) || m(options)) {
    options = {
      content: options
    };
  }
  const placement = options.placement || options.position || "top";
  const currentManager = messageManagers[placement] ? messageManagers[placement] : messageManagers[placement] = new MessageManager({
    placement,
    root: options.root || "body"
  });
  const id = currentManager.push({
    content: options.content,
    icon: options.icon,
    duration: options.duration || 3e3,
    type: options.type || "normal",
    color: options.color,
    closable: options.closable
  });
  return {
    close: () => currentManager.close(id),
    clear: () => currentManager.clear()
  };
};
const message = messageCall;
["info", "success", "warning", "error", "loading", "sakura", "normal"].forEach(
  (key) => {
    message[key] = (options) => {
      if (p(options) || m(options)) {
        options = {
          content: options
        };
      }
      return message({
        ...options,
        type: key
      });
    };
  }
);
export {
  message as m,
  nanoid as n
};
