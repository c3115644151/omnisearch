import './css.js'
import { defineComponent, computed, useSlots, createVNode, Fragment } from "vue";
import { f as flattenVNodes } from "../share/util/render.js";
import { k } from "../aside/index.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "Space"
  },
  __name: "index",
  props: {
    margin: {
      default: "medium"
    },
    direction: {
      default: "horizontal"
    },
    justify: {
      default: "start"
    },
    align: null,
    wrap: {
      type: Boolean,
      default: true
    },
    inline: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const alignComputed = computed(() => {
      if (props.align) {
        return props.align;
      }
      return props.direction === "horizontal" ? "center" : "stretch";
    });
    const slots = useSlots();
    const marginComputed = computed(() => {
      if (!props.margin || props.margin === "small" || props.margin === "medium" || props.margin === "large") {
        return;
      }
      if (k(props.margin)) {
        return {
          x: props.margin,
          y: props.margin
        };
      }
      if ("x" in props.margin || "y" in props.margin) {
        const x = k(props.margin.x) ? props.margin.x : 0;
        const y = k(props.margin.y) ? props.margin.y : 0;
        return {
          x,
          y
        };
      }
    });
    return () => {
      var _a;
      const children = flattenVNodes(((_a = slots.default) == null ? void 0 : _a.call(slots)) || []);
      return createVNode("div", {
        "class": {
          pixelium: true,
          "px-space": true,
          [`px-space__inline`]: !!props.inline
        }
      }, [createVNode("div", {
        "class": {
          "px-space-inner": true,
          [`px-space__small`]: props.margin === "small",
          [`px-space__large`]: props.margin === "large",
          [`px-space__justify-${props.justify}`]: true,
          [`px-space__align-${alignComputed.value}`]: true,
          [`px-space__${props.direction}`]: true,
          [`px-space__wrap`]: !!props.wrap
        },
        "style": {
          marginTop: marginComputed.value ? -marginComputed.value.y / 2 + "px" : void 0,
          marginBottom: marginComputed.value ? -marginComputed.value.y / 2 + "px" : void 0,
          marginLeft: marginComputed.value ? -marginComputed.value.x / 2 + "px" : void 0,
          marginRight: marginComputed.value ? -marginComputed.value.x / 2 + "px" : void 0
        }
      }, [children.map((child, index) => createVNode(Fragment, {
        "key": child.key || `px-space-item-${index}`
      }, [createVNode("div", {
        "class": "px-space-item",
        "style": {
          marginTop: marginComputed.value ? marginComputed.value.y / 2 + "px" : void 0,
          marginBottom: marginComputed.value ? marginComputed.value.y / 2 + "px" : void 0,
          marginLeft: marginComputed.value ? marginComputed.value.x / 2 + "px" : void 0,
          marginRight: marginComputed.value ? marginComputed.value.x / 2 + "px" : void 0
        }
      }, [child])]))])]);
    };
  }
});
export {
  _sfc_main as _
};
