import './css.js'
import { defineComponent, getCurrentInstance, ref, inject, useId, computed, onMounted, watch, onBeforeUnmount, createElementBlock, openBlock, normalizeStyle, renderSlot } from "vue";
import { _ as _sfc_main$1 } from "../grid/index.js";
import { k } from "../aside/index.js";
import { u as useScreenWidth } from "../share/hook/use-screen-width.js";
import { u as useIndexOfChildren } from "../share/hook/use-index-of-children.js";
import { G as GRID_UPDATE } from "../share/const/event-bus-key.js";
import { G as GRID_PROVIDE } from "../share/const/provide-key.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "GridItem"
  },
  __name: "index",
  props: {
    offset: { default: 0 },
    span: null
  },
  setup(__props) {
    var _a;
    const instance = getCurrentInstance();
    const inner = ref(((_a = instance == null ? void 0 : instance.parent) == null ? void 0 : _a.type) === _sfc_main$1);
    const provide = inner.value ? inject(GRID_PROVIDE) : void 0;
    const props = __props;
    const id = useId();
    const [index] = useIndexOfChildren(GRID_UPDATE);
    const [widthType] = useScreenWidth();
    const offsetComputed = computed(() => {
      if (k(props.offset)) {
        return props.offset;
      }
      return props.offset[widthType.value] || 0;
    });
    const spanComputed = computed(() => {
      if (props.span === void 0) {
        return (provide == null ? void 0 : provide.column.value) || 24;
      }
      if (k(props.span)) {
        return props.span;
      }
      return props.span[widthType.value] || 24;
    });
    onMounted(() => {
      provide == null ? void 0 : provide.itemsStat.value.push({
        id,
        index: index.value,
        offset: offsetComputed.value,
        span: spanComputed.value
      });
    });
    watch([index, offsetComputed, spanComputed], () => {
      const stat = provide == null ? void 0 : provide.itemsStat.value.find((item) => item.id === id);
      if (stat) {
        stat.index = index.value;
        stat.offset = offsetComputed.value;
        stat.span = spanComputed.value;
      } else {
        provide == null ? void 0 : provide.itemsStat.value.push({
          id,
          index: index.value,
          offset: offsetComputed.value,
          span: spanComputed.value
        });
      }
    });
    onBeforeUnmount(() => {
      const idx = provide == null ? void 0 : provide.itemsStat.value.findIndex((item) => item.id === id);
      if (idx !== void 0 && idx > -1) {
        provide == null ? void 0 : provide.itemsStat.value.splice(idx, 1);
      }
    });
    const gridColumn = computed(() => {
      if (!provide) {
        return;
      }
      if (offsetComputed.value + spanComputed.value > provide.column.value) {
        return `${offsetComputed.value + 1} / span ${spanComputed.value}`;
      }
      const preItems = provide.itemsStat.value.filter(
        (item) => item.index !== -1 && item.index < index.value
      );
      if (preItems.length === 0) {
        return `${offsetComputed.value + 1} / span ${spanComputed.value}`;
      }
      let start = 0;
      preItems.forEach((item) => {
        if (item.span + item.offset >= provide.column.value) {
          start = 0;
          return;
        }
        start += item.span + item.offset;
        if (start > provide.column.value) {
          start = item.span + item.offset;
        } else if (start === provide.column.value) {
          start = 0;
        }
      });
      let occupied = start + offsetComputed.value + spanComputed.value;
      if (occupied > provide.column.value) {
        return `${offsetComputed.value + 1} / span ${spanComputed.value}`;
      }
      return `${start + offsetComputed.value + 1} / span ${spanComputed.value}`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          class: "pixelium px-grid-item",
          style: normalizeStyle({
            gridColumn: gridColumn.value
          })
        },
        [
          renderSlot(_ctx.$slots, "default")
        ],
        4
        /* STYLE */
      );
    };
  }
});
export {
  _sfc_main as _
};
