import './css.js'
import { defineComponent, shallowRef, ref, onMounted, nextTick, watch, createElementBlock, openBlock, normalizeStyle, createCommentVNode } from "vue";
import { u as useResizeObserver } from "../share/hook/use-resize-observer.js";
import { a as canvasPreprocess } from "../share/util/plot.js";
import { u as useWatchGlobalCssVal } from "../share/hook/use-watch-global-css-var.js";
import { g as getGlobalThemeColor, r as rgbaColor2string } from "../share/util/color.js";
import { C as COVER_Z_INDEX } from "../share/const/index.js";
import { u as useDarkMode } from "../share/hook/use-dark-mode.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "Mask"
  },
  __name: "index",
  props: {
    color: null,
    step: { default: 1 },
    lineWidth: { default: 2 },
    grid: { type: Boolean, default: true },
    zIndex: { default: COVER_Z_INDEX }
  },
  setup(__props) {
    const darkMode = useDarkMode();
    const props = __props;
    const canvasRef = shallowRef(null);
    const wrapperRef = shallowRef(null);
    const calcDefaultBackgroundColor = () => {
      const color = getGlobalThemeColor("neutral", 8);
      color.a = Math.floor(255 * 0.5);
      return rgbaColor2string(color);
    };
    const defaultBackgroundColor = ref(calcDefaultBackgroundColor());
    const drawGrid = () => {
      if (!props.grid) {
        return;
      }
      const preprocessData = canvasPreprocess(wrapperRef, canvasRef);
      if (!preprocessData) {
        return;
      }
      const { ctx, width, height } = preprocessData;
      const lineWidth = props.lineWidth;
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = props.color || defaultBackgroundColor.value;
      ctx.lineWidth = lineWidth;
      const step = Math.max(1, props.step);
      for (let x = 0; x <= width; x += step + lineWidth) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y <= height; y += step + lineWidth) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    };
    onMounted(() => {
      nextTick(() => {
        drawGrid();
      });
    });
    useResizeObserver(wrapperRef, drawGrid);
    useWatchGlobalCssVal(() => {
      drawGrid();
      defaultBackgroundColor.value = calcDefaultBackgroundColor();
    });
    watch(
      [
        darkMode,
        defaultBackgroundColor,
        () => props.grid,
        () => props.color,
        () => props.step,
        () => props.lineWidth
      ],
      () => {
        defaultBackgroundColor.value = calcDefaultBackgroundColor();
        drawGrid();
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          class: "pixelium px-mask",
          style: normalizeStyle({
            zIndex: props.zIndex,
            backgroundColor: !props.grid ? props.color || defaultBackgroundColor.value : void 0
          }),
          ref_key: "wrapperRef",
          ref: wrapperRef
        },
        [
          props.grid ? (openBlock(), createElementBlock(
            "canvas",
            {
              key: 0,
              ref_key: "canvasRef",
              ref: canvasRef,
              class: "px-mask-canvas"
            },
            null,
            512
            /* NEED_PATCH */
          )) : createCommentVNode("v-if", true)
        ],
        4
        /* STYLE */
      );
    };
  }
});
export {
  _sfc_main as _
};
