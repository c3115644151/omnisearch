import './css.js'
import { defineComponent, computed, ref, shallowRef, watch, onMounted, nextTick, useSlots, createVNode, Fragment } from "vue";
import { N } from "../aside/index.js";
import { _ as _sfc_main$2 } from "../popup-content/index.js";
import { _ as _sfc_main$1 } from "../popup-trigger/index.js";
import { i as inBrowser } from "../share/util/env.js";
const BORDER_RADIUS = 16;
const HOVER_CLOSE_DELAY = 300;
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "Popover"
  },
  __name: "index",
  props: {
    content: null,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    placement: {
      default: "top"
    },
    trigger: {
      default: "hover"
    },
    offset: {
      default: 8
    },
    variant: {
      default: "light"
    },
    arrow: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean
    },
    zIndex: null,
    root: {
      default: "body"
    },
    widthEqual: {
      type: Boolean,
      default: false
    },
    contentStyle: null
  },
  emits: ["update:visible", "close", "open"],
  setup(__props, {
    expose: __expose,
    emit: __emit
  }) {
    const props = __props;
    const controlledMode = computed(() => {
      return props.visible !== void 0;
    });
    const preDisplay = controlledMode.value ? props.visible : props.defaultVisible;
    const display = ref(N(preDisplay) ? false : preDisplay);
    const contentRef = shallowRef();
    const triggerRef = shallowRef();
    const emits = __emit;
    const currentTrigger = shallowRef(null);
    let closeDelayPromiseReject;
    async function openHandler(node, e) {
      if (closeDelayPromiseReject) {
        closeDelayPromiseReject();
        closeDelayPromiseReject = void 0;
      }
      await openHandlerImpl(node);
      emits("open", e);
    }
    async function openHandlerImpl(node, controlled = false) {
      if (inBrowser()) {
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
        if (node.el instanceof HTMLElement) {
          currentTrigger.value = node;
        } else {
          currentTrigger.value = null;
        }
        if (currentTrigger.value && currentTrigger.value.el instanceof HTMLElement) {
          resizeObserver == null ? void 0 : resizeObserver.observe(currentTrigger.value.el);
        }
      }
      if (controlledMode.value && !controlled) {
        emits("update:visible", true);
        await nextTick(() => {
        });
        display.value = !!props.visible;
      } else {
        display.value = true;
      }
    }
    async function closeHandler(e) {
      if (props.trigger === "click") {
        const clickContent = contentRef.value && contentRef.value.content && contentRef.value.content.contains(e.target);
        if (clickContent || !display.value) {
          return;
        }
      } else {
        if (closeDelayPromiseReject) {
          closeDelayPromiseReject();
          closeDelayPromiseReject = void 0;
        }
        const {
          resolve,
          reject,
          promise
        } = Promise.withResolvers();
        closeDelayPromiseReject = reject;
        setTimeout(() => {
          resolve();
        }, HOVER_CLOSE_DELAY);
        try {
          await promise;
        } catch {
          return;
        }
      }
      if (controlledMode.value) {
        emits("update:visible", false);
        await nextTick(() => {
        });
        display.value = !!props.visible;
      } else {
        display.value = false;
      }
      emits("close", e);
    }
    const contentMouseenterHandler = () => {
      if (props.trigger === "click") {
        return;
      }
      if (closeDelayPromiseReject) {
        closeDelayPromiseReject();
        closeDelayPromiseReject = void 0;
      }
    };
    const contentMouseleaveHandler = (e) => {
      if (props.trigger === "click") {
        return;
      }
      closeHandler(e);
    };
    const preprocessCurrentTrigger = () => {
      if (!inBrowser()) {
        return;
      }
      if (!currentTrigger.value && triggerRef.value && triggerRef.value.firstVNode) {
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
        currentTrigger.value = triggerRef.value.firstVNode;
        if (currentTrigger.value.el instanceof HTMLElement) {
          resizeObserver == null ? void 0 : resizeObserver.observe(currentTrigger.value.el);
        }
      }
    };
    const processVisible = (value) => {
      if (value) {
        preprocessCurrentTrigger();
        if (currentTrigger.value) {
          openHandlerImpl(currentTrigger.value, true);
        }
      } else {
        display.value = false;
      }
    };
    watch(() => props.visible, () => {
      processVisible(!!props.visible);
    });
    const resizeObserver = inBrowser() ? new ResizeObserver(() => {
      updateRenderState();
    }) : null;
    onMounted(() => {
      nextTick(() => {
        if (display.value) {
          updateRenderState();
        }
      });
    });
    const updateRenderState = () => {
      var _a;
      preprocessCurrentTrigger();
      if (inBrowser()) {
        (_a = contentRef.value) == null ? void 0 : _a.updateRenderState();
      }
    };
    __expose({
      triggerContent: contentRef,
      updateRenderState
    });
    const slots = useSlots();
    const checkCurrentTrigger = (_) => {
      var _a;
      if (!inBrowser()) {
        return false;
      }
      return ((_a = currentTrigger.value) == null ? void 0 : _a.el) instanceof HTMLElement;
    };
    return () => {
      var _a;
      return createVNode(Fragment, null, [createVNode(_sfc_main$1, {
        "trigger": props.trigger,
        "disabled": props.disabled,
        "onClose": closeHandler,
        "onOpen": openHandler,
        "ref": (node) => triggerRef.value = node
      }, {
        default: () => {
          var _a2;
          return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
        }
      }), createVNode(_sfc_main$2, {
        "visible": display.value,
        "content": props.content,
        "zIndex": props.zIndex,
        "variant": props.variant,
        "placement": props.placement,
        "arrow": props.arrow,
        "offset": props.offset,
        "borderRadius": BORDER_RADIUS,
        "root": props.root,
        "widthEqual": props.widthEqual,
        "target": checkCurrentTrigger((_a = currentTrigger.value) == null ? void 0 : _a.el) ? currentTrigger.value.el : null,
        "onContentMouseenter": contentMouseenterHandler,
        "onContentMouseleave": contentMouseleaveHandler,
        "contentStyle": props.contentStyle,
        "ref": (node) => contentRef.value = node
      }, {
        content: slots.content
      })]);
    };
  }
});
export {
  _sfc_main as _
};
