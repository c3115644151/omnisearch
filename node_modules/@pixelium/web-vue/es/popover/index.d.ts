import { nextTick, type VNode } from 'vue';
import type { PopoverProps } from './type';
declare const _default: import("vue").DefineComponent<PopoverProps, {
    triggerContent: import("vue").ShallowRef<({
        $: import("vue").ComponentInternalInstance;
        $data: {};
        $props: {
            readonly content?: string | undefined;
            readonly visible?: boolean | null | undefined;
            readonly defaultVisible?: boolean | null | undefined;
            readonly placement?: "top" | "right" | "bottom" | "left" | "top-start" | "top-end" | "right-start" | "right-end" | "bottom-start" | "bottom-end" | "left-start" | "left-end" | undefined;
            readonly offset?: number | undefined;
            readonly variant?: "dark" | "light" | undefined;
            readonly arrow?: boolean | undefined;
            readonly zIndex?: number | undefined;
            readonly target?: (HTMLElement | VNode | null) | undefined;
            readonly root?: (HTMLElement | string) | undefined;
            readonly borderRadius?: number | undefined;
            readonly widthEqual?: boolean | undefined;
            readonly contentStyle?: import("vue").CSSProperties | undefined;
            readonly onContentMouseenter?: ((e: MouseEvent) => any) | undefined;
            readonly onContentMouseleave?: ((e: MouseEvent) => any) | undefined;
        } & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("vue").Slot<any> | undefined;
        }>;
        $root: import("vue").ComponentPublicInstance | null;
        $parent: import("vue").ComponentPublicInstance | null;
        $host: Element | null;
        $emit: ((event: "contentMouseenter", e: MouseEvent) => void) & ((event: "contentMouseleave", e: MouseEvent) => void);
        $el: any;
        $options: import("vue").ComponentOptionsBase<Readonly<import("../popup-content/type.ts").PopupContentProps> & Readonly<{
            onContentMouseenter?: ((e: MouseEvent) => any) | undefined;
            onContentMouseleave?: ((e: MouseEvent) => any) | undefined;
        }>, {
            updateRenderState: () => void;
            content: import("vue").ShallowRef<HTMLDivElement | null, HTMLDivElement | null>;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
            contentMouseenter: (e: MouseEvent) => any;
            contentMouseleave: (e: MouseEvent) => any;
        }, string, {
            variant: "dark" | "light";
            placement: "top" | "right" | "bottom" | "left" | "top-start" | "top-end" | "right-start" | "right-end" | "bottom-start" | "bottom-end" | "left-start" | "left-end";
            root: HTMLElement | string;
            offset: number;
            visible: boolean | null;
            arrow: boolean;
            widthEqual: boolean;
        }, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, ((cleanupFn: () => void) => void)]) => any : (...args: [any, any, ((cleanupFn: () => void) => void)]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
    } & Readonly<{
        variant: "dark" | "light";
        placement: "top" | "right" | "bottom" | "left" | "top-start" | "top-end" | "right-start" | "right-end" | "bottom-start" | "bottom-end" | "left-start" | "left-end";
        root: HTMLElement | string;
        offset: number;
        visible: boolean | null;
        arrow: boolean;
        widthEqual: boolean;
    }> & Omit<Readonly<import("../popup-content/type.ts").PopupContentProps> & Readonly<{
        onContentMouseenter?: ((e: MouseEvent) => any) | undefined;
        onContentMouseleave?: ((e: MouseEvent) => any) | undefined;
    }>, "content" | ("variant" | "placement" | "root" | "offset" | "visible" | "arrow" | "widthEqual") | "updateRenderState"> & import("vue").ShallowUnwrapRef<{
        updateRenderState: () => void;
        content: import("vue").ShallowRef<HTMLDivElement | null, HTMLDivElement | null>;
    }> & {} & import("vue").ComponentCustomProperties & {} & {
        $slots: {
            content?: (props: {}) => any;
        };
    }) | undefined, ({
        $: import("vue").ComponentInternalInstance;
        $data: {};
        $props: {
            readonly content?: string | undefined;
            readonly visible?: boolean | null | undefined;
            readonly defaultVisible?: boolean | null | undefined;
            readonly placement?: "top" | "right" | "bottom" | "left" | "top-start" | "top-end" | "right-start" | "right-end" | "bottom-start" | "bottom-end" | "left-start" | "left-end" | undefined;
            readonly offset?: number | undefined;
            readonly variant?: "dark" | "light" | undefined;
            readonly arrow?: boolean | undefined;
            readonly zIndex?: number | undefined;
            readonly target?: (HTMLElement | VNode | null) | undefined;
            readonly root?: (HTMLElement | string) | undefined;
            readonly borderRadius?: number | undefined;
            readonly widthEqual?: boolean | undefined;
            readonly contentStyle?: import("vue").CSSProperties | undefined;
            readonly onContentMouseenter?: ((e: MouseEvent) => any) | undefined;
            readonly onContentMouseleave?: ((e: MouseEvent) => any) | undefined;
        } & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("vue").Slot<any> | undefined;
        }>;
        $root: import("vue").ComponentPublicInstance | null;
        $parent: import("vue").ComponentPublicInstance | null;
        $host: Element | null;
        $emit: ((event: "contentMouseenter", e: MouseEvent) => void) & ((event: "contentMouseleave", e: MouseEvent) => void);
        $el: any;
        $options: import("vue").ComponentOptionsBase<Readonly<import("../popup-content/type.ts").PopupContentProps> & Readonly<{
            onContentMouseenter?: ((e: MouseEvent) => any) | undefined;
            onContentMouseleave?: ((e: MouseEvent) => any) | undefined;
        }>, {
            updateRenderState: () => void;
            content: import("vue").ShallowRef<HTMLDivElement | null, HTMLDivElement | null>;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
            contentMouseenter: (e: MouseEvent) => any;
            contentMouseleave: (e: MouseEvent) => any;
        }, string, {
            variant: "dark" | "light";
            placement: "top" | "right" | "bottom" | "left" | "top-start" | "top-end" | "right-start" | "right-end" | "bottom-start" | "bottom-end" | "left-start" | "left-end";
            root: HTMLElement | string;
            offset: number;
            visible: boolean | null;
            arrow: boolean;
            widthEqual: boolean;
        }, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, ((cleanupFn: () => void) => void)]) => any : (...args: [any, any, ((cleanupFn: () => void) => void)]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
    } & Readonly<{
        variant: "dark" | "light";
        placement: "top" | "right" | "bottom" | "left" | "top-start" | "top-end" | "right-start" | "right-end" | "bottom-start" | "bottom-end" | "left-start" | "left-end";
        root: HTMLElement | string;
        offset: number;
        visible: boolean | null;
        arrow: boolean;
        widthEqual: boolean;
    }> & Omit<Readonly<import("../popup-content/type.ts").PopupContentProps> & Readonly<{
        onContentMouseenter?: ((e: MouseEvent) => any) | undefined;
        onContentMouseleave?: ((e: MouseEvent) => any) | undefined;
    }>, "content" | ("variant" | "placement" | "root" | "offset" | "visible" | "arrow" | "widthEqual") | "updateRenderState"> & import("vue").ShallowUnwrapRef<{
        updateRenderState: () => void;
        content: import("vue").ShallowRef<HTMLDivElement | null, HTMLDivElement | null>;
    }> & {} & import("vue").ComponentCustomProperties & {} & {
        $slots: {
            content?: (props: {}) => any;
        };
    }) | undefined>;
    updateRenderState: () => void;
}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
    close: (e: MouseEvent) => any;
    open: (e: MouseEvent) => any;
    "update:visible": (value: boolean) => any;
}, string, import("vue").PublicProps, Readonly<PopoverProps> & Readonly<{
    onClose?: ((e: MouseEvent) => any) | undefined;
    onOpen?: ((e: MouseEvent) => any) | undefined;
    "onUpdate:visible"?: ((value: boolean) => any) | undefined;
}>, {
    variant: "dark" | "light";
    placement: "top" | "right" | "bottom" | "left" | "top-start" | "top-end" | "right-start" | "right-end" | "bottom-start" | "bottom-end" | "left-start" | "left-end";
    root: HTMLElement | string;
    offset: number;
    visible: boolean | null;
    defaultVisible: boolean | null;
    arrow: boolean;
    widthEqual: boolean;
    trigger: "hover" | "click";
}, {}, {}, {}, string, import("vue").ComponentProvideOptions, false, {}, any>;
export default _default;
