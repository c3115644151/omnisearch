import './css.js'
import { defineComponent, getCurrentInstance, ref, inject, computed, shallowRef, onMounted, nextTick, watch, createElementBlock, openBlock, normalizeClass, createElementVNode, renderSlot } from "vue";
import { a as canvasPreprocess, c as calcPixelSize, g as getBorderRadius, b as calcBorderCornerCenter, f as floodFill } from "../share/util/plot.js";
import { g as getGlobalThemeColor, p as parseColor } from "../share/util/color.js";
import { _ as _sfc_main$1 } from "../input-group/index.js";
import { d as drawBorder } from "./draw.js";
import { u as useDarkMode } from "../share/hook/use-dark-mode.js";
import { u as useResizeObserver } from "../share/hook/use-resize-observer.js";
import { u as useWatchGlobalCssVal } from "../share/hook/use-watch-global-css-var.js";
import { u as useIndexOfChildren } from "../share/hook/use-index-of-children.js";
import { I as INPUT_GROUP_UPDATE } from "../share/const/event-bus-key.js";
import { I as INPUT_GROUP_PROVIDE } from "../share/const/provide-key.js";
import { B as BORDER_CORNER_RAD_RANGE } from "../share/const/index.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "InputGroupLabel"
  },
  __name: "index",
  props: {
    backgroundColor: null,
    borderRadius: null,
    shape: { default: "default" },
    size: { default: "medium" }
  },
  setup(__props) {
    var _a;
    const props = __props;
    const instance = getCurrentInstance();
    const innerInputGroup = ref(((_a = instance == null ? void 0 : instance.parent) == null ? void 0 : _a.type) === _sfc_main$1);
    const [_, first, last] = innerInputGroup.value ? useIndexOfChildren(INPUT_GROUP_UPDATE) : [ref(0), ref(false), ref(false)];
    const inputGroupProps = inject(INPUT_GROUP_PROVIDE);
    const borderRadiusComputed = computed(() => {
      return innerInputGroup.value && inputGroupProps ? inputGroupProps.borderRadius : props.borderRadius;
    });
    const sizeComputed = computed(() => {
      return innerInputGroup.value && inputGroupProps ? inputGroupProps.size : props.size;
    });
    const shapeComputed = computed(() => {
      return innerInputGroup.value && inputGroupProps ? inputGroupProps.shape : props.shape;
    });
    const hoverFlag = ref(false);
    const activeFlag = ref(false);
    const darkMode = useDarkMode();
    const canvasRef = shallowRef(null);
    const labelRef = shallowRef(null);
    onMounted(() => {
      nextTick(() => {
        drawPixel();
      });
    });
    watch([borderRadiusComputed, shapeComputed, hoverFlag, activeFlag, darkMode], () => {
      drawPixel();
    });
    watch([first, last], () => {
      drawPixel();
    });
    const drawPixel = () => {
      const preprocessData = canvasPreprocess(labelRef, canvasRef);
      if (!preprocessData) {
        return;
      }
      const { ctx, width, height, canvas } = preprocessData;
      const pixelSize = calcPixelSize();
      const borderRadius = getBorderRadius(
        canvas,
        pixelSize,
        borderRadiusComputed.value,
        shapeComputed.value,
        sizeComputed.value || "medium",
        innerInputGroup.value,
        first.value,
        last.value
      );
      const borderColor = getGlobalThemeColor("neutral", 10);
      const center = calcBorderCornerCenter(borderRadius, width, height, pixelSize);
      const rad = BORDER_CORNER_RAD_RANGE;
      drawBorder(
        ctx,
        width,
        height,
        center,
        borderRadius,
        rad,
        borderColor,
        pixelSize,
        innerInputGroup.value,
        first.value,
        last.value
      );
      const backgroundColor = props.backgroundColor ? parseColor(props.backgroundColor) : getGlobalThemeColor("neutral", 3);
      floodFill(ctx, Math.round(width / 2), Math.round(height / 2), backgroundColor);
    };
    useResizeObserver(labelRef, drawPixel);
    useWatchGlobalCssVal(drawPixel);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(["pixelium px-input-group-label", {
            "px-input-group-label__large": sizeComputed.value === "large",
            "px-input-group-label__small": sizeComputed.value === "small",
            "px-input-group-label__inner": innerInputGroup.value
          }]),
          ref_key: "labelRef",
          ref: labelRef
        },
        [
          createElementVNode(
            "canvas",
            {
              ref_key: "canvasRef",
              ref: canvasRef,
              class: "px-input-group-label-canvas"
            },
            null,
            512
            /* NEED_PATCH */
          ),
          renderSlot(_ctx.$slots, "default")
        ],
        2
        /* CLASS */
      );
    };
  }
});
export {
  _sfc_main as _
};
