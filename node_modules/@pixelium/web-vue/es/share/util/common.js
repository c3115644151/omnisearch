import { d } from "../../aside/index.js";
import { G as GROUP_OPTION_TYPE } from "../const/index.js";
const clamp = (x, min, max) => Math.max(min, Math.min(max, x));
const fillArr = (val, size) => Array(size).fill(val);
const defaultFilter = (keyword, list = []) => {
  if (!keyword) {
    return [...list];
  }
  const keyword4Search = keyword.toLowerCase();
  const len = list.length;
  const ans = [];
  for (let i = 0; i < len; i++) {
    const currentElement = list[i];
    if (d(currentElement)) {
      if ("type" in currentElement && currentElement.type === GROUP_OPTION_TYPE) {
        const children = defaultFilter(keyword, currentElement.children);
        if (children.length) {
          ans.push({
            ...currentElement,
            children
          });
        }
      } else {
        if (currentElement.label.toLowerCase().includes(keyword4Search)) {
          ans.push(currentElement);
        }
      }
    } else {
      if (currentElement.toLowerCase().includes(keyword4Search)) {
        ans.push(currentElement);
      }
    }
  }
  return ans;
};
const findSameOption = (keyword, list, checkLabel = false) => {
  if (!keyword) {
    return [];
  }
  const len = list.length;
  const ans = [];
  for (let i = 0; i < len; i++) {
    const currentElement = list[i];
    if (d(currentElement)) {
      if ("type" in currentElement && currentElement.type === GROUP_OPTION_TYPE) {
        const options = findSameOption(keyword, currentElement.children, checkLabel);
        if (options.length) {
          ans.push(options[0], currentElement);
          break;
        }
      } else {
        if (checkLabel && currentElement.label === keyword || currentElement.value === keyword) {
          ans.push(currentElement);
          break;
        }
      }
    } else {
      if (currentElement === keyword) {
        ans.push(currentElement);
        break;
      }
    }
  }
  return ans;
};
export {
  findSameOption as a,
  clamp as c,
  defaultFilter as d,
  fillArr as f
};
