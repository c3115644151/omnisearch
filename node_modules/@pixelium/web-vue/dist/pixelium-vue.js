var Ao = Object.defineProperty;
var Do = (t, n, o) => n in t ? Ao(t, n, { enumerable: !0, configurable: !0, writable: !0, value: o }) : t[n] = o;
var Jt = (t, n, o) => Do(t, typeof n != "symbol" ? n + "" : n, o);
import { defineComponent as X, createElementBlock as B, openBlock as C, normalizeStyle as oe, createElementVNode as z, onUpdated as zn, ref as R, getCurrentInstance as et, onMounted as Re, nextTick as ae, onBeforeUnmount as Ue, provide as Ut, renderSlot as ee, computed as M, inject as Ze, useSlots as je, shallowRef as S, watch as we, normalizeClass as se, createCommentVNode as ue, unref as V, createBlock as Ve, createVNode as I, Transition as eo, onUnmounted as Oo, useModel as No, Fragment as De, renderList as Nt, useAttrs as Mn, Teleport as to, mergeProps as Rn, render as In, Text as Fo, useId as Go, onScopeDispose as Wo, withModifiers as vt, toDisplayString as Ae, withCtx as _t, withDirectives as Zt, createTextVNode as Je, vShow as St, cloneVNode as Uo, withKeys as jo, h as no } from "vue";
const ot = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M23 9v6h-1v2h-3v-2h1V9h-1V7h-1V6h-1V5h-2V4h-2V3h-1V1h3v1h2v1h2v1h1v1h1v2h1v2z" }, null, -1)
    ])], 4));
  }
}), Xo = /\.|\[(\d+)\]/;
function qo(t) {
  return t.split(Xo).filter(Boolean);
}
function Ln(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function jt(t) {
  return t !== null && (typeof t == "object" || typeof t == "function");
}
function Yo(t, n, o) {
  const e = qo(n), l = e.length;
  let a = t;
  for (let r = 0; r < l; r++)
    if (jt(a))
      a = a[e[r]];
    else
      return o;
  return o ?? a;
}
function Xt(t) {
  return typeof t == "function";
}
function Ko(t, n, o = {}) {
  const { start: e = "{", end: l = "}" } = o, a = new RegExp(
    `${Ln(e)}(.*?)${Ln(l)}`,
    "g"
  );
  return t.replace(a, (r, s) => (Xt(n) ? n(s) : Yo(n, s)) ?? r);
}
function Pe(t) {
  return typeof t == "string" || t instanceof String;
}
function Qo(t) {
  return t === null;
}
function he(t) {
  return typeof t == "number" || t instanceof Number;
}
function Jo(t) {
  return t === void 0;
}
function rt(t) {
  return Array.isArray(t);
}
function Zo(t) {
  return he(t) && (typeof t == "number" ? t === 1 / 0 || t === -1 / 0 : t.valueOf() === 1 / 0 || t.valueOf() === -1 / 0);
}
function fn(t) {
  return he(t) && (typeof t == "number" ? Number.isNaN(t) : Number.isNaN(t.valueOf()));
}
function Me(t) {
  return t == null;
}
function oo(...t) {
  return t.reduce((n, o) => {
    if (Me(o))
      return n;
    const e = Object.keys(o);
    for (const l of e) {
      const a = n[l], r = o[l];
      (Me(a) || !Me(r)) && (n[l] = r);
    }
    return n;
  }, {});
}
function So(t, n, o) {
  let e, l;
  const { immediate: a = !1, maxWait: r } = o || {};
  return function(...s) {
    r !== void 0 && !l && (l = setTimeout(() => {
      l = void 0, t.apply(this, s);
    }, r)), !e && a && t.apply(this, s), e && clearTimeout(e), e = setTimeout(() => {
      l && (clearTimeout(l), l = void 0), t.apply(this, s);
    }, n);
  };
}
// @ts-ignore
typeof process < "u" && process.env.NODE_ENV;
const ke = {
  r: 0,
  g: 0,
  b: 0,
  a: 0
}, ao = 20;
var xt = /* @__PURE__ */ ((t) => (t.XS = "xs", t.SM = "sm", t.MD = "md", t.LG = "lg", t.XL = "xl", t.XXL = "xxl", t))(xt || {});
const Ct = "group", it = [
  [Math.PI, Math.PI * 3 / 2],
  [Math.PI * 3 / 2, Math.PI * 2],
  [0, Math.PI / 2],
  [Math.PI / 2, Math.PI]
], Dt = (t, n, o) => Math.max(n, Math.min(o, t)), Ie = (t, n) => Array(n).fill(t), Hn = (t, n = []) => {
  if (!t)
    return [...n];
  const o = t.toLowerCase(), e = n.length, l = [];
  for (let a = 0; a < e; a++) {
    const r = n[a];
    if (jt(r))
      if ("type" in r && r.type === Ct) {
        const s = Hn(t, r.children);
        s.length && l.push({
          ...r,
          children: s
        });
      } else
        r.label.toLowerCase().includes(o) && l.push(r);
    else
      r.toLowerCase().includes(o) && l.push(r);
  }
  return l;
}, zt = (t, n, o = !1) => {
  if (!t)
    return [];
  const e = n.length, l = [];
  for (let a = 0; a < e; a++) {
    const r = n[a];
    if (jt(r)) {
      if ("type" in r && r.type === Ct) {
        const s = zt(t, r.children, o);
        if (s.length) {
          l.push(s[0], r);
          break;
        }
      } else if (o && r.label === t || r.value === t) {
        l.push(r);
        break;
      }
    } else if (r === t) {
      l.push(r);
      break;
    }
  }
  return l;
}, ie = () => typeof window < "u";
function zo(t, n, o, e) {
  let l = Math.atan2(n, t);
  return l < 0 && (l += Math.PI * 2), l >= o && l <= e;
}
function ea(t, n, o, e, l, a, r, s) {
  const u = [
    [n, o],
    [-n, o],
    [n, -o],
    [-n, -o],
    [o, n],
    [-o, n],
    [o, -n],
    [-o, -n]
  ];
  for (const [f, c] of u)
    zo(f, c, a, r) && t.fillRect(e + f, l + c, s, s);
}
function Fe(t, n, o, e, l = 0, a = Math.PI * 2, r) {
  let s = 0, u = e, f = 3 - 2 * e;
  for (; s <= u + r; )
    ea(t, s, u, n, o, l, a, r), s += r, f > 0 ? (u -= r, f += 4 * (s - u) + 10) : f += 4 * s + 6;
}
function ct(t, n, o, e) {
  const l = t.canvas.width, a = t.canvas.height;
  if (l <= 0 || a <= 0)
    return;
  const r = t.getImageData(0, 0, l, a), s = new Uint32Array(r.data.buffer), u = e.a << 24 | e.b << 16 | e.g << 8 | e.r, f = o * l + n, c = s[f];
  if (c === u) return;
  const i = [], d = m(n, o, 1);
  d && i.push({ ...d, dy: 1 });
  const p = m(n, o - 1, -1);
  for (p && i.push({ ...p, dy: -1 }); i.length; ) {
    const { y: v, left: h, right: w, dy: y } = i.pop(), g = v + y;
    if (g < 0 || g >= a) continue;
    let _ = h;
    for (; _ <= w; ) {
      for (; _ <= w && s[g * l + _] !== c; ) _++;
      if (_ > w) break;
      const x = _, k = m(x, g, y);
      k && i.push(k), _ = k ? k.right + 1 : x + 1;
    }
  }
  t.putImageData(r, 0, 0);
  function m(v, h, w) {
    let y = v;
    for (; y > 0 && s[h * l + y - 1] === c; ) y--;
    let g = v;
    for (; g < l - 1 && s[h * l + g + 1] === c; ) g++;
    for (let _ = y; _ <= g; _++) s[h * l + _] = u;
    return { y: h, left: y, right: g, dy: w };
  }
}
const xe = (t, n, o) => he(n) ? Math.max(n, o) : Math.max(t.height * parseFloat(n) / 100, o), ta = (t, n, o) => {
  if (!n) return Ie(o, 4);
  if (!rt(n))
    return Ie(xe(t, n, o), 4);
  switch (n.length) {
    case 1:
      return Ie(xe(t, n[0], o), 4);
    case 2: {
      const e = xe(t, n[0], o), l = xe(t, n[1], o);
      return [e, l, e, l];
    }
    case 3: {
      const e = xe(t, n[0], o), l = xe(t, n[2], o), a = xe(t, n[1], o);
      return [e, a, l, a];
    }
    default:
      return n.map((e) => xe(t, e, o));
  }
}, na = (t, n, o, e, l) => {
  if (!n) return Ie(o, 4);
  if (!rt(n)) {
    const a = xe(t, n, o);
    return l ? [o, a, a, o] : e ? [a, o, o, a] : Ie(o, 4);
  }
  switch (n.length) {
    case 1:
      const a = xe(t, n[0], o);
      return l ? [o, a, a, o] : e ? [a, o, o, a] : Ie(o, 4);
    case 2: {
      const r = xe(t, n[0], o), s = xe(t, n[1], o);
      return l ? [o, s, s, o] : e ? [r, o, o, r] : Ie(o, 4);
    }
    case 3: {
      const r = xe(t, n[0], o), s = xe(t, n[2], o), u = xe(t, n[1], o);
      return l ? [o, u, s, o] : e ? [r, o, o, u] : Ie(o, 4);
    }
    default:
      return l ? [
        o,
        xe(t, n[1], o),
        xe(t, n[2], o),
        o
      ] : e ? [
        xe(t, n[0], o),
        o,
        o,
        xe(t, n[3], o)
      ] : Ie(o, 4);
  }
}, gt = (t, n, o, e, l = "medium", a = !1, r = !1, s = !1) => {
  if (!ie())
    return Ie(n, 4);
  if (a) {
    if (o)
      return na(t, o, n, r, s);
    const u = getComputedStyle(document.documentElement), f = parseInt(u.getPropertyValue(`--px-${l}-base-size`)) + 2 * n;
    switch (e) {
      case "round":
        let c = xe(t, "50%", n);
        c = Dt(c, n, f / 2), c = Math.max(Math.round(c / n) * n, n);
        const i = Ie(c, 4);
        return s ? i.map((d, p) => p < 1 || p > 2 ? n : d) : r ? i.map((d, p) => p > 0 && p < 3 ? n : d) : Ie(n, 4);
      default:
        return Ie(n, 4);
    }
  } else {
    if (o)
      return ta(t, o, n);
    switch (e) {
      case "round":
      case "circle":
        let u = xe(t, "50%", n);
        return u = Math.max(Math.round(u / n) * n, n), Ie(u, 4);
      default:
        return Ie(n, 4);
    }
  }
};
function Et(t, n) {
  return Math.ceil(
    (-6 + Math.sqrt(36 - 48 * t + 32 * t * n)) / (8 * t)
  ) * t;
}
const Ne = () => {
  if (!ie())
    return 4;
  const t = getComputedStyle(document.documentElement);
  return parseInt(t.getPropertyValue("--px-bit"));
}, ft = (t, n, o, e, l = 0, a = 0) => [
  [t[0], t[0]],
  [n - l - t[1] - e, t[1]],
  [
    n - l - t[2] - e,
    o - a - t[2] - e
  ],
  [t[3], o - a - t[3] - e]
], Xe = (t, n) => {
  if (!n.value || !t.value) return;
  const o = n.value.getContext("2d", { willReadFrequently: !0 });
  if (!o) return;
  o.imageSmoothingEnabled = !1;
  const e = t.value.getBoundingClientRect();
  if (!(e.width <= 0 || e.height <= 0))
    return n.value.width = e.width, n.value.height = e.height, {
      ctx: o,
      width: n.value.width,
      height: n.value.height,
      rect: e,
      canvas: n.value
    };
};
function lo(t) {
  if (!Number.isInteger(t) || t <= 0)
    throw new RangeError("max must be a positive integer");
  const n = /* @__PURE__ */ new Map();
  return {
    get(o) {
      const e = n.get(o);
      if (e !== void 0)
        return n.delete(o), n.set(o, e), e;
    },
    set(o, e) {
      n.has(o) ? n.delete(o) : n.size >= t && n.delete(n.keys().next().value), n.set(o, e);
    },
    delete(o) {
      return n.delete(o);
    },
    clear() {
      n.clear();
    },
    has(o) {
      return n.has(o);
    },
    get size() {
      return n.size;
    }
  };
}
const En = lo(120);
function Rt(t) {
  const n = En.get(t);
  if (n) return { ...n };
  let o = { r: 0, g: 0, b: 0, a: 255 };
  if (t.startsWith("rgb(") || t.startsWith("rgba(")) {
    const e = t.match(/rgba?\(\s*(\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i);
    e && (o.r = parseInt(e[1], 10), o.g = parseInt(e[2], 10), o.b = parseInt(e[3], 10), e[4] && (o.a = Math.round(parseFloat(e[4]) * 255)));
  } else t.startsWith("#") && (t = t.slice(1), t.length === 3 ? (o.r = parseInt(t[0] + t[0], 16), o.g = parseInt(t[1] + t[1], 16), o.b = parseInt(t[2] + t[2], 16)) : t.length === 4 ? (o.r = parseInt(t[0] + t[0], 16), o.g = parseInt(t[1] + t[1], 16), o.b = parseInt(t[2] + t[2], 16), o.a = parseInt(t[3] + t[3], 16)) : t.length === 6 ? (o.r = parseInt(t.slice(0, 2), 16), o.g = parseInt(t.slice(2, 4), 16), o.b = parseInt(t.slice(4, 6), 16)) : t.length === 8 && (o.r = parseInt(t.slice(0, 2), 16), o.g = parseInt(t.slice(2, 4), 16), o.b = parseInt(t.slice(4, 6), 16), o.a = parseInt(t.slice(6, 8), 16)));
  return En.set(t, o), { ...o };
}
const b = (t, n) => ie() ? Rt(
  getComputedStyle(document.documentElement).getPropertyValue(`--px-${t}-${n}`)
) : ke;
function dn(t) {
  return t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function oa(t, n, o, e = 255) {
  const l = t / 255, a = n / 255, r = o / 255, s = dn(l), u = dn(a), f = dn(r);
  let c = s * 0.41239079926595934 + u * 0.357584339383878 + f * 0.1804807884018343, i = s * 0.21263900587151027 + u * 0.715168678767756 + f * 0.07219231536073371, d = s * 0.01933081871559182 + u * 0.11919477979462598 + f * 0.9505321522496607, p = 0.819022437996703 * c + 0.3619062600528904 * i - 0.1288737815209879 * d, m = 0.0329836539323885 * c + 0.9292868615863434 * i + 0.0361446663506424 * d, v = 0.0481771893596242 * c + 0.2642395317527308 * i + 0.6335478284694309 * d;
  p = Math.cbrt(p), m = Math.cbrt(m), v = Math.cbrt(v);
  const h = 0.210454268309314 * p + 0.7936177747023054 * m - 0.0040720430116193 * v, w = 1.9779985324311684 * p - 2.42859224204858 * m + 0.450593709617411 * v, y = 0.0259040424655478 * p + 0.7827717124575296 * m - 0.8086757549230774 * v, g = Math.sqrt(w * w + y * y);
  let _ = Math.atan2(y, w) * 180 / Math.PI;
  return _ < 0 && (_ += 360), {
    l: h,
    c: g,
    h: _,
    a: e
  };
}
function pn(t) {
  return t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055;
}
function en(t, n, o, e = 255) {
  const l = o * Math.PI / 180, a = n * Math.cos(l), r = n * Math.sin(l);
  let s = t + 0.3963377773761749 * a + 0.2158037573099136 * r, u = t - 0.1055613458156586 * a - 0.0638541728258133 * r, f = t - 0.0894841775298119 * a - 1.2914855480194092 * r;
  s = s * s * s, u = u * u * u, f = f * f * f;
  const c = 1.2268798758459243 * s - 0.5578149944602171 * u + 0.2813910456659647 * f, i = -0.0405757452148008 * s + 1.112286803280317 * u - 0.0717110580655164 * f, d = -0.0763729366746601 * s - 0.4214933324022432 * u + 1.5869240198367816 * f, p = 3.2409699419045226 * c - 1.537383177570094 * i - 0.4986107602930034 * d, m = -0.9692436362808796 * c + 1.8759675015077202 * i + 0.04155505740717559 * d, v = 0.05563007969699366 * c - 0.20397695888897652 * i + 1.0569715142428786 * d, h = pn(p), w = pn(m), y = pn(v);
  return {
    r: Math.round(h * 255),
    g: Math.round(w * 255),
    b: Math.round(y * 255),
    a: e
  };
}
function aa(t, n, o) {
  const { r: e, g: l, b: a } = en(n, t, o);
  return e >= 0 && e <= 255 && l >= 0 && l <= 255 && a >= 0 && a <= 255;
}
function vn(t, n) {
  let e = 0, l = 2;
  for (; l - e > 1e-6; ) {
    const a = (e + l) / 2;
    aa(a, t, n) ? e = a : l = a;
  }
  return e;
}
const An = lo(60);
function Tt(t, n, o, e = 255, l = !1) {
  const a = `${t},${n},${o},${e},${l}`, r = An.get(a);
  if (r) return r;
  const s = oa(t, n, o, e);
  let u = [];
  const f = s.c < 0.049 ? 0 : 0.049, c = l ? Math.min(Math.max(s.l, 0.05), 0.85) : Math.min(Math.max(s.l, 0.15), 0.95), i = Math.min(Math.max(s.c, f), vn(c, s.h)), d = Math.min(c + 0.35, l ? 0.85 : 0.9), p = Math.max(c - 0.35, l ? 0.1 : 0.15), m = l ? (c - p) / 4 : (d - c) / 4, v = (i - f) / 4, h = l ? (d - c) / 3 : (c - p) / 3, w = (i - f) / 3;
  for (let y = 0; y < 5; y++) {
    const g = c + (l ? -1 : 1) * m * (5 - y), _ = Math.min(i - v * (5 - y), vn(g, s.h)), x = s.h, k = en(g, _, x, e);
    u.push(k);
  }
  u.push(en(c, i, s.h, e));
  for (let y = 0; y < 4; y++) {
    const g = c - (l ? -1 : 1) * h * (y + 1), _ = Math.min(i - w * (y + 1), vn(g, s.h)), x = s.h, k = en(g, _, x, e);
    u.push(k);
  }
  return An.set(a, u), u;
}
const j = (t) => `rgba(${t.r}, ${t.g}, ${t.b}, ${t.a / 255})`;
function la(t) {
  return { all: t = t || /* @__PURE__ */ new Map(), on: function(n, o) {
    var e = t.get(n);
    e ? e.push(o) : t.set(n, [o]);
  }, off: function(n, o) {
    var e = t.get(n);
    e && (o ? e.splice(e.indexOf(o) >>> 0, 1) : t.set(n, []));
  }, emit: function(n, o) {
    var e = t.get(n);
    e && e.slice().map(function(l) {
      l(o);
    }), (e = t.get("*")) && e.slice().map(function(l) {
      l(n, o);
    });
  } };
}
const Bt = la(), ut = (t) => {
  const n = R(-1), o = R(!1), e = R(!1), l = et(), a = () => {
    if (l && l.vnode.el instanceof HTMLElement) {
      const r = l.vnode.el.parentElement;
      if (r && r.children.length) {
        const s = [...r.children];
        n.value = s.indexOf(l.vnode.el), o.value = n.value === r.children.length - 1, e.value = n.value === 0;
      } else
        n.value = -1, o.value = !1, e.value = !1;
    }
  };
  return ie() && (Bt.on(t, a), Re(() => {
    ae(() => {
      a();
    });
  }), zn(() => {
    a();
  }), Ue(() => {
    Bt.off(t, a);
  })), [n, e, o];
}, kn = (t) => {
  zn(() => {
    Bt.emit(t);
  });
}, so = "px-button-group-update", ro = "px-grid-update", yn = "px-global-css-var-change", yt = "px-input-group-update", uo = "px-button-group-provide", bt = "px-input-group-provide", io = "px-grid-provide", sa = { class: "pixelium px-button-group" }, co = /* @__PURE__ */ X({
  name: "ButtonGroup",
  __name: "index",
  props: {
    borderRadius: null,
    shape: { default: "default" },
    size: { default: "medium" },
    disabled: { type: Boolean, default: !1 },
    loading: { type: Boolean },
    variant: null
  },
  setup(t) {
    return Ut(uo, t), kn(so), (o, e) => (C(), B("div", sa, [
      ee(o.$slots, "default")
    ]));
  }
}), ra = {
  class: "pixelium px-input-group",
  ref: "slotWrapper"
}, wt = /* @__PURE__ */ X({
  name: "InputGroup",
  __name: "index",
  props: {
    borderRadius: null,
    shape: { default: "default" },
    size: { default: "medium" },
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    return Ut(bt, t), kn(yt), (o, e) => (C(), B("div", ra, [
      ee(o.$slots, "default")
    ], 512));
  }
});
function ua(t, n, o, e = "primary", l, a, r) {
  if (l)
    switch (o) {
      case "text":
        return t ? ke : r ? l[1] : a && !n ? l[0] : ke;
      case "outline":
        return ke;
      case "plain":
        return t ? l[0] : r ? l[2] : a && !n ? l[1] : l[0];
      default:
        return t ? l[1] : r ? l[5] : a && !n ? l[4] : l[5];
    }
  else if (e !== "info")
    switch (o) {
      case "text":
        return t ? ke : r ? b(e, 2) : a && !n ? b(e, 1) : ke;
      case "outline":
        return ke;
      case "plain":
        return t ? b(e, 1) : r ? b(e, 3) : a && !n ? b(e, 2) : b(e, 1);
      default:
        return t ? b(e, 2) : r ? b(e, 6) : a && !n ? b(e, 5) : b(e, 6);
    }
  else
    switch (o) {
      case "outline":
        return ke;
      case "text":
        return t ? ke : r ? b("neutral", 3) : a && !n ? b("neutral", 2) : ke;
      case "plain":
        return t ? b("neutral", 1) : r ? b("neutral", 4) : a && !n ? b("neutral", 3) : b("neutral", 1);
      default:
        return t ? b("neutral", 1) : r ? b("neutral", 3) : a && !n ? b("neutral", 2) : b("neutral", 1);
    }
}
function ia(t, n, o, e = "primary", l, a, r) {
  if (l)
    switch (o) {
      case "text":
        return t ? ke : r ? l[1] : a && !n ? l[0] : ke;
      case "plain":
        return t ? l[1] : r ? l[3] : a && !n ? l[2] : l[1];
      case "outline":
        return t ? l[0] : r ? l[6] : a && !n ? l[4] : l[5];
      default:
        return t ? b("neutral", 8) : b("neutral", 10);
    }
  else if (e !== "info")
    switch (o) {
      case "text":
        return t ? ke : r ? b(e, 2) : a && !n ? b(e, 1) : ke;
      case "plain":
        return t ? b(e, 2) : r ? b(e, 4) : a && !n ? b(e, 3) : b(e, 2);
      case "outline":
        return t ? b(e, 1) : r ? b(e, 7) : a && !n ? b(e, 5) : b(e, 6);
      default:
        return t ? b("neutral", 8) : b("neutral", 10);
    }
  else {
    switch (o) {
      case "text":
        return t ? ke : r ? b("neutral", 3) : a && !n ? b("neutral", 2) : ke;
      case "plain":
        return t ? b("neutral", 5) : r ? b("neutral", 9) : a && !n ? b("neutral", 8) : b("neutral", 7);
      case "outline":
        return t ? b("neutral", 6) : r ? b("neutral", 8) : a && !n ? b("neutral", 9) : b("neutral", 10);
    }
    return t ? b("neutral", 8) : b("neutral", 10);
  }
}
const ca = (t, n, o, e, l, a, r, s, u, f, c, i) => {
  t.fillStyle = j(r);
  for (let p = 0; p < 4; p++)
    l[p] > s && (!(p === 1 || p === 2) || f && (i || u === "text") || !f) && Fe(
      t,
      e[p][0],
      e[p][1],
      l[p],
      a[p][0],
      a[p][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(e[0][0], 0, e[1][0] - e[0][0] + s, s), e[2][1] + s > e[1][1] && (f && (i || u === "text") || !f) && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0],
    o - s,
    e[2][0] - e[3][0] + s,
    s
  ), !(f && !c && u !== "text") && e[3][1] + s > e[0][1] && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s), f && !c && u !== "text" && t.fillRect(s / 2, 0, s / 2, o), f && !i && u !== "text" && t.fillRect(n - 2 * s - 1, 0, s, o);
};
function Dn(t, n, o = "primary", e, l, a) {
  return e ? t ? e[0] : a ? e[6] : l && !n ? e[3] : e[4] : o !== "info" ? t ? b(o, 1) : a ? b(o, 7) : l && !n ? b(o, 4) : b(o, 5) : t ? b("neutral", 2) : a ? b("neutral", 5) : l && !n ? b("neutral", 4) : b("neutral", 3);
}
const fa = (t, n, o, e, l, a, r, s, u, f = "primary", c, i, d, p, m, v) => {
  const h = Et(r, l[2]), w = Et(r, l[3]), y = Et(r, l[1]), g = Et(r, l[0]), _ = +!(i && !d), x = +!i || i && p;
  if (!v || s) {
    const k = Dn(s, u, f, c, m, v);
    t.fillStyle = j(k), l[1] > r && (Fe(
      t,
      e[1][0] - r,
      e[1][1],
      l[1],
      a[1][0],
      a[1][1],
      r
    ), t.globalCompositeOperation = "destination-out", t.fillRect(e[1][0] - r, 0, g, r), t.globalCompositeOperation = "source-over"), l[2] > r && (Fe(
      t,
      e[2][0] - r,
      e[2][1],
      l[2],
      a[2][0],
      a[2][1],
      r
    ), t.globalCompositeOperation = "destination-out", t.fillRect(e[2][0] - r, o - r, w, r), t.globalCompositeOperation = "source-over");
    const H = e[2][0] + r - e[3][0] + w * _ + h * +x - 1 * +!x;
    H > 0 && t.fillRect(
      e[3][0] - w * _,
      o - r * 2,
      H,
      r
    );
    const L = e[2][1] + r - e[1][1] + y + h;
    L > 0 && t.fillRect(
      n - r * 2 - (p ? 0 : +i * r * 1),
      e[1][1] - y,
      r,
      L
    );
  } else {
    const k = Dn(s, u, f, c, m, v);
    t.fillStyle = j(k), l[0] > r && (Fe(
      t,
      e[0][0] + r,
      e[0][1],
      l[0],
      a[0][0],
      a[0][1],
      r
    ), t.globalCompositeOperation = "destination-out", t.fillRect(e[0][0] + r, 0, y, r), t.globalCompositeOperation = "source-over"), l[3] > r && (Fe(
      t,
      e[3][0] + r,
      e[3][1],
      l[3],
      a[3][0],
      a[3][1],
      r
    ), t.globalCompositeOperation = "destination-out", t.fillRect(e[3][0] + r, o - r, h, r), t.globalCompositeOperation = "source-over");
    const H = e[1][0] + r - e[0][0] + y * +x + g * _ - 1 * +!x;
    H > 0 && t.fillRect(e[0][0] - g * _, r, H, r);
    const L = r + e[3][1] - e[0][1] + w + g;
    L > 0 && t.fillRect(r, e[0][1] - g, r, L);
  }
}, da = (t, n, o, e, l, a) => {
  if (!(!t || n === "primary")) {
    if (o)
      return j(n === "plain" ? t[2] : t[1]);
    if (e) return j(t[5]);
    if (a && n !== "plain") return j(t[6]);
    switch (n) {
      case "text":
        return j(t[5]);
      case "outline":
        return j(l ? t[4] : t[5]);
      case "plain":
        return j(t[5]);
      default:
        return;
    }
  }
}, On = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap(), pa = (t) => () => {
  const n = At.get(t);
  n == null || n.forEach((o) => o());
}, Le = () => {
  const t = R(!1), n = R(void 0);
  function o(l) {
    t.value = l.matches;
  }
  if (ie()) {
    const l = window.matchMedia("(prefers-color-scheme: dark)");
    o(l), l.addEventListener("change", o), Ue(() => {
      l.removeEventListener("change", o);
    });
  }
  const e = () => {
    if (ie()) {
      let l = !1, a = !1;
      document.documentElement.className.split(" ").forEach((r) => {
        r === "dark" && (l = !0), r === "light" && (a = !0);
      }), n.value = l ? !0 : a ? !1 : void 0;
    }
  };
  return ie() && (Re(() => {
    const l = On.get(document.documentElement) || new MutationObserver(pa(document.documentElement));
    On.set(document.documentElement, l), l.observe(document.documentElement, {
      attributes: !0,
      attributeFilter: ["class"]
    }), At.set(document.documentElement, [
      ...At.get(document.documentElement) || [],
      e
    ]), e();
  }), Ue(() => {
    At.set(
      document.documentElement,
      (At.get(document.documentElement) || []).filter(
        (l) => l !== e
      )
    );
  })), M(() => n.value ?? t.value);
}, We = (t, n, o) => {
  if (!ie())
    return null;
  const e = new ResizeObserver(n);
  return Re(() => {
    setTimeout(() => {
      o && n(), t.value && e.observe(t.value);
    });
  }), Ue(() => {
    e.disconnect();
  }), e;
}, qe = (t) => {
  if (!ie())
    return;
  const n = () => {
    t();
  };
  Bt.on(yn, n), Ue(() => {
    Bt.off(yn, n);
  });
}, va = ["disabled", "type", "autofocus"], ma = /* @__PURE__ */ X({
  name: "Button",
  __name: "index",
  props: {
    borderRadius: null,
    shape: { default: "default" },
    size: { default: "medium" },
    disabled: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    variant: { default: "primary" },
    theme: { default: "primary" },
    color: null,
    block: { type: Boolean, default: !1 },
    nativeType: { default: "button" },
    autofocus: { type: Boolean, default: !1 }
  },
  setup(t) {
    var D, U;
    const n = t, o = et(), e = R(((D = o == null ? void 0 : o.parent) == null ? void 0 : D.type) === co), l = R(((U = o == null ? void 0 : o.parent) == null ? void 0 : U.type) === wt), [a, r, s] = e.value ? ut(so) : l.value ? ut(yt) : [R(0), R(!1), R(!1)], u = Ze(uo), f = Ze(bt), c = M(() => e.value && u ? u.borderRadius : l.value && f ? f.borderRadius : n.borderRadius), i = M(() => e.value && u && u.variant || n.variant), d = M(() => e.value && u ? u.size : l.value && f ? f.size : n.size), p = M(() => e.value && u ? u.shape : l.value && f ? f.shape : n.shape), m = M(() => e.value && u ? u.disabled || n.disabled : l.value && f && f.disabled || n.disabled), v = M(() => e.value && u && u.loading || n.loading), h = je(), w = R(!1), y = R(!1), g = (A) => {
      w.value = A;
    }, _ = (A) => {
      y.value = A;
    }, x = Le(), k = S(null), H = S(null);
    Re(() => {
      ae(() => {
        G();
      });
    });
    const L = M(() => {
      if (!n.color) return null;
      const A = Rt(n.color);
      return Tt(A.r, A.g, A.b, A.a, x.value);
    }), E = M(() => da(
      L.value,
      i.value,
      m.value,
      v.value,
      w.value,
      y.value
    ));
    we(
      [
        c,
        p,
        m,
        v,
        i,
        () => n.theme,
        L,
        w,
        y,
        x
      ],
      () => {
        G();
      }
    ), we([r, s], () => {
      G();
    });
    const G = () => {
      const A = Xe(H, k);
      if (!A)
        return;
      const F = Ne(), { ctx: K, width: ne, height: O, canvas: Q } = A, W = gt(
        Q,
        F,
        c.value,
        p.value,
        d.value || "medium",
        e.value || l.value,
        r.value,
        s.value
      ), _e = ia(
        m.value,
        v.value,
        i.value,
        n.theme,
        L.value,
        w.value,
        y.value
      ), pe = ft(W, ne, O, F), be = it;
      i.value === "primary" && fa(
        K,
        ne,
        O,
        pe,
        W,
        be,
        F,
        m.value,
        v.value,
        n.theme,
        L.value,
        e.value || l.value,
        r.value,
        s.value,
        w.value,
        y.value
      ), ca(
        K,
        ne,
        O,
        pe,
        W,
        be,
        _e,
        F,
        i.value,
        e.value || l.value,
        r.value,
        s.value
      );
      const ce = ua(
        m.value,
        v.value,
        i.value,
        n.theme,
        L.value,
        w.value,
        y.value
      );
      ct(K, Math.round(ne / 2), Math.round(O / 2), ce);
    };
    return We(H, G), qe(G), (A, F) => (C(), B("button", {
      disabled: m.value || v.value,
      class: se(["pixelium px-button", {
        "px-button__block": !(e.value || l.value) && !!n.block,
        "px-button__circle": p.value === "circle",
        "px-button__square": p.value === "square",
        "px-button__loading": v.value,
        "px-button__large": d.value === "large",
        "px-button__small": d.value === "small",
        "px-button__outline": i.value === "outline",
        "px-button__plain": i.value === "plain",
        "px-button__text": i.value === "text",
        "px-button__disabled": m.value,
        "px-button__custom": L.value,
        "px-button__inner": e.value || l.value,
        [`px-button__${n.theme || "primary"}`]: !0
      }]),
      style: oe({
        color: E.value
      }),
      ref_key: "buttonRef",
      ref: H,
      onMouseenter: F[0] || (F[0] = (K) => g(!0)),
      onMouseleave: F[1] || (F[1] = (K) => g(!1)),
      onMousedown: F[2] || (F[2] = (K) => _(!0)),
      onMouseup: F[3] || (F[3] = (K) => _(!1)),
      type: n.nativeType,
      autofocus: n.autofocus
    }, [
      z("canvas", {
        ref_key: "canvasRef",
        ref: k,
        class: "px-button-canvas"
      }, null, 512),
      V(h).icon || v.value ? (C(), B("div", {
        key: 0,
        class: se(["px-button-icon-wrapper", {
          "px-button-icon-wrapper__last": !V(h).default
        }])
      }, [
        v.value ? (C(), Ve(V(ot), {
          key: 0,
          class: "px-button-icon px-animation__loading",
          style: oe({
            fill: E.value
          })
        }, null, 8, ["style"])) : ee(A.$slots, "icon", { key: 1 })
      ], 2)) : ue("", !0),
      ee(A.$slots, "default")
    ], 46, va));
  }
}), ha = ["href", "target"], ga = /* @__PURE__ */ X({
  name: "Link",
  __name: "index",
  props: {
    disabled: { type: Boolean },
    loading: { type: Boolean },
    theme: null,
    color: null,
    href: null,
    target: null
  },
  setup(t) {
    const n = t, o = je(), e = Le(), l = M(() => {
      if (!n.color) return null;
      const d = Rt(n.color);
      return Tt(d.r, d.g, d.b, d.a, e.value);
    }), a = R(!1), r = R(!1), s = (d) => {
      a.value = d;
    }, u = (d) => {
      r.value = d;
    }, f = (d, p, m, v, h) => {
      if (d)
        return j(p ? d[1] : m ? d[5] : h ? d[6] : v ? d[4] : d[5]);
    }, c = M(() => f(
      l.value,
      n.disabled,
      n.loading,
      a.value,
      r.value
    )), i = (d) => {
      (n.disabled || n.loading) && d.preventDefault();
    };
    return (d, p) => (C(), B("a", {
      class: se(["pixelium px-link", {
        "px-link__loading": n.loading,
        "px-link__disabled": n.disabled,
        "px-link__custom": l.value,
        [`px-link__${n.theme || "primary"}`]: !0
      }]),
      style: oe({
        color: c.value
      }),
      onMouseenter: p[0] || (p[0] = (m) => s(!0)),
      onMouseleave: p[1] || (p[1] = (m) => s(!1)),
      onMousedown: p[2] || (p[2] = (m) => u(!0)),
      onMouseup: p[3] || (p[3] = (m) => u(!1)),
      href: n.href,
      target: n.target,
      onClick: i
    }, [
      V(o).icon || n.loading ? (C(), B("div", {
        key: 0,
        class: se(["px-link-icon-wrapper", {
          "px-link-icon-wrapper__last": !V(o).default
        }])
      }, [
        n.loading ? (C(), Ve(V(ot), {
          key: 0,
          class: "px-link-icon px-animation__loading",
          style: oe({
            fill: c.value
          })
        }, null, 8, ["style"])) : ee(d.$slots, "icon", { key: 1 })
      ], 2)) : ue("", !0),
      ee(d.$slots, "default")
    ], 46, ha));
  }
}), ya = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M22 9V7h-1V5h-1V4h-1V3h-2V2h-2V1H9v1H7v1H5v1H4v1H3v2H2v2H1v6h1v2h1v2h1v1h1v1h2v1h2v1h6v-1h2v-1h2v-1h1v-1h1v-2h1v-2h1V9zM11 6h2v2h-2zm-1 9h1v-5h-1V9h3v6h1v2h-4z" }, null, -1),
      z("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1)
    ])], 4));
  }
}), ba = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M22 20v-2h-1v-2h-1v-2h-1v-2h-1v-2h-1V8h-1V6h-1V4h-1V2h-1V1h-2v1h-1v2H9v2H8v2H7v2H6v2H5v2H4v2H3v2H2v2H1v2h1v1h20v-1h1v-2zm-12-9h4v3h-1v3h-2v-3h-1zm1 7h2v2h-2z" }, null, -1)
    ])], 4));
  }
}), wa = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M22 8V7h-1V6h-1V5h-1V4h-1V3h-1V2h-1V1H8v1H7v1H6v1H5v1H4v1H3v1H2v1H1v8h1v1h1v1h1v1h1v1h1v1h1v1h1v1h8v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1V8zm-6 9h-2v-1h-1v-1h-2v1h-1v1H8v-1H7v-2h1v-1h1v-2H8v-1H7V8h1V7h2v1h1v1h2V8h1V7h2v1h1v2h-1v1h-1v2h1v1h1v2h-1z" }, null, -1)
    ])], 4));
  }
}), _a = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M22 9V7h-1V5h-1V4h-1V3h-2V2h-2V1H9v1H7v1H5v1H4v1H3v2H2v2H1v6h1v2h1v2h1v1h1v1h2v1h2v1h6v-1h2v-1h2v-1h1v-1h1v-2h1v-2h1V9zm-4 3h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-2v-1H9v-1H8v-1H7v-1H6v-2h1v-1h2v1h1v1h2v-1h1v-1h1v-1h1V9h1V8h2v1h1v2h-1z" }, null, -1)
    ])], 4));
  }
}), Ht = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M22 9V7h-1V5h-1V4h-1V3h-2V2h-2V1H9v1H7v1H5v1H4v1H3v2H2v2H1v6h1v2h1v2h1v1h1v1h2v1h2v1h6v-1h2v-1h2v-1h1v-1h1v-2h1v-2h1V9zm-8 7v-1h-1v-1h-2v1h-1v1H9v1H8v-1H7v-1h1v-1h1v-1h1v-2H9v-1H8V9H7V8h1V7h1v1h1v1h1v1h2V9h1V8h1V7h1v1h1v1h-1v1h-1v1h-1v2h1v1h1v1h1v1h-1v1h-1v-1z" }, null, -1)
    ])], 4));
  }
}), xa = /* @__PURE__ */ X({
  __name: "index",
  props: {
    content: {
      default: ""
    },
    icon: null,
    duration: {
      default: 3e3
    },
    id: null,
    type: {
      default: "normal"
    },
    color: null,
    closable: {
      type: Boolean
    }
  },
  emits: ["close"],
  setup(t, {
    expose: n,
    emit: o
  }) {
    const e = t, l = R(!1), a = R(!1), r = (E) => {
      a.value = E;
    }, s = (E) => {
      l.value = E;
    }, u = R(!1);
    let f;
    Re(() => {
      u.value = !0, c();
    }), Ue(() => {
      clearTimeout(f);
    });
    function c() {
      f = setTimeout(() => d(), e.duration);
    }
    function i() {
      clearTimeout(f), f = void 0;
    }
    function d() {
      u.value = !1;
    }
    const p = o, m = () => {
      p("close", e.id), i();
    }, v = S(null), h = S(null), w = (E) => {
      if (!E)
        return "normal";
      switch (E) {
        case "info":
          return "primary";
        case "error":
          return "danger";
        default:
          return E;
      }
    }, y = Le(), g = M(() => {
      if (!e.color) return null;
      const E = Rt(e.color);
      return Tt(E.r, E.g, E.b, E.a, y.value);
    }), _ = M(() => g.value ? j(g.value[5]) : void 0), x = M(() => {
      if (g.value)
        return a.value ? j(g.value[6]) : l.value ? j(g.value[4]) : j(g.value[5]);
    });
    function k(E = "normal", G) {
      if (G)
        return G[5];
      {
        const D = w(E);
        return D === "normal" ? b("neutral", 10) : D === "loading" ? b("neutral", 8) : b(D, 6);
      }
    }
    const H = (E, G, D, U, A) => {
      E.fillStyle = j(U), E.fillRect(A, 0, G - 2 * A, A), E.fillRect(G - A, A, A, D - 2 * A), E.fillRect(A, D - A, G - 2 * A, A), E.fillRect(0, A, A, D - 2 * A);
      const F = b("neutral", 1);
      E.fillStyle = j(F), E.fillRect(A, A, G - 2 * A, D - 2 * A);
    }, L = () => {
      const E = Xe(h, v);
      if (!E)
        return;
      const {
        ctx: G,
        width: D,
        height: U
      } = E, A = Ne(), F = k(e.type, g.value);
      H(G, D, U, F, A);
    };
    return We(h, L), qe(L), we([() => e.type, g, y], () => {
      setTimeout(() => {
        L();
      });
    }), n({
      close: d
    }), () => I(eo, {
      name: "px-message-fade",
      onAfterLeave: m
    }, {
      default: () => [u.value && I("div", {
        ref: (E) => h.value = E,
        onMouseenter: i,
        onMouseleave: c,
        class: {
          "px-message": !0,
          pixelium: !0,
          [`px-message__${e.type || "primary"}`]: !0
        }
      }, [(!!e.icon || e.type && e.type !== "normal" && e.type !== "sakura") && I("div", {
        class: "px-message-icon-wrapper"
      }, [e.icon ? e.icon() : e.type === "info" ? I(ya, {
        class: "px-message-icon",
        style: {
          fill: _.value
        }
      }, null) : e.type === "success" ? I(_a, {
        class: "px-message-icon",
        style: {
          fill: _.value
        }
      }, null) : e.type === "warning" ? I(ba, {
        class: "px-message-icon",
        style: {
          fill: _.value
        }
      }, null) : e.type === "error" ? I(wa, {
        class: "px-message-icon",
        style: {
          fill: _.value
        }
      }, null) : e.type === "loading" && I(ot, {
        class: "px-message-icon px-animation__loading",
        style: {
          fill: _.value
        }
      }, null)]), I("span", {
        class: "px-message-content",
        style: {
          color: _.value
        }
      }, [Pe(e.content) ? e.content : e.content()]), e.closable && I("div", {
        class: "px-message-close-wrapper"
      }, [I(Ht, {
        class: "px-message-icon",
        style: {
          fill: x.value
        },
        onMouseenter: s(!0),
        onMouseleave: s(!1),
        onMousedown: r(!0),
        onMouseup: r(!1),
        onClick: d
      }, null)]), I("canvas", {
        ref: (E) => v.value = E,
        class: "px-message-canvas"
      }, null)])]
    });
  }
}), Ca = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let bn = (t = 21) => {
  let n = "", o = crypto.getRandomValues(new Uint8Array(t |= 0));
  for (; t--; )
    n += Ca[o[t] & 63];
  return n;
};
const Ma = {
  message: { start: 3e3 },
  popup: { start: 1e3 }
}, mn = {};
function Ra(t, n) {
  return mn[t] || (mn[t] = { max: n.start, count: 0, initial: n.start }), mn[t];
}
function fo(t = "popup") {
  const n = Ma[t], o = Ra(t, n), e = R(++o.max);
  o.count++;
  const l = () => (e.value = ++o.max, e.value), a = () => {
    --o.count === 0 && (o.max = o.initial);
  };
  return Oo(a), [e, l, a];
}
const po = /* @__PURE__ */ X({
  name: "MessageBoxInner",
  __name: "message-box",
  props: {
    messages: {},
    placement: { default: "top" },
    position: { default: "top" },
    zIndex: {},
    root: {},
    "onUpdate:messages": {}
  },
  emits: ["close"],
  setup(t, { expose: n, emit: o }) {
    const e = t, [l] = fo("message"), a = No(e, "messages"), r = o, s = M(() => a.value.map((c) => ({
      ...c,
      id: c.id ?? bn()
    }))), u = (c) => {
      if (!Me(c)) {
        if (e["onUpdate:messages"]) {
          const i = s.value.findIndex((d) => d.id === c);
          if (i >= 0) {
            const d = [...s.value];
            d.splice(i, 1), a.value = d;
          }
        }
        r("close", c);
      }
    }, f = S([]);
    return n({
      close: (c) => {
        var d;
        const i = s.value.findIndex((p) => p.id === c);
        i !== -1 && ((d = f.value[i]) == null || d.close());
      }
    }), (c, i) => (C(), B("div", {
      class: "px-message-box",
      style: oe({
        zIndex: e.zIndex ?? V(l)
      })
    }, [
      z("div", {
        class: se(["px-message-box-container", {
          [`px-message-box-container__${e.placement || e.position || "top"}`]: !0
        }])
      }, [
        (C(!0), B(De, null, Nt(s.value, (d) => (C(), Ve(xa, {
          key: d.id,
          duration: d.duration,
          content: d.content,
          id: d.id,
          onClose: u,
          type: d.type,
          color: d.color,
          icon: d.icon,
          closable: d.closable,
          ref_for: !0,
          ref_key: "messageRef",
          ref: f
        }, null, 8, ["duration", "content", "id", "type", "color", "icon", "closable"]))), 128))
      ], 2)
    ], 4));
  }
}), Ha = /* @__PURE__ */ X({
  name: "MessageBox",
  __name: "message-box-wrapped",
  props: {
    messages: null,
    placement: null,
    position: null,
    zIndex: null,
    root: { default: "body" },
    "onUpdate:messages": { type: Function },
    onClose: { type: Function }
  },
  setup(t, { expose: n }) {
    const o = t, e = Mn(), l = R(null);
    return n({
      close: (a) => {
        var r;
        (r = l.value) == null || r.close(a);
      }
    }), (a, r) => (C(), Ve(to, {
      to: o.root
    }, [
      I(po, Rn({ ...o, ...V(e) }, {
        ref_key: "messageBoxRef",
        ref: l
      }), null, 16)
    ], 8, ["to"]));
  }
});
class ka {
  constructor(n) {
    Jt(this, "messages");
    Jt(this, "messageBox");
    Jt(this, "container", null);
    this.messages = R([]), this.messageBox = I(po, {
      messages: this.messages.value,
      placement: n.placement,
      onClose: (l) => {
        const a = this.messages.value.findIndex((r) => r.id === l);
        a >= 0 && this.messages.value.splice(a, 1);
      }
    });
    const o = (Pe(n.root) ? document.querySelector(n.root) : n.root) || document.body, e = bn();
    this.container = document.createElement("div"), this.container.id = e, this.container.className = "px-message-box-wrapper", o.appendChild(this.container), In(this.messageBox, this.container);
  }
  push(n) {
    const o = n.id ?? bn();
    return this.messages.value.push({
      ...n,
      id: o
    }), o;
  }
  close(n) {
    var o, e;
    (e = (o = this.messageBox.component) == null ? void 0 : o.exposed) == null || e.close(n);
  }
  clear() {
    this.messages.value.length = 0;
  }
  unmount() {
    if (this.container) {
      const n = this.container;
      In(this.messageBox, n), ae(() => {
        n.remove(), this.container = null;
      });
    }
  }
}
const hn = {
  top: void 0,
  bottom: void 0,
  "top-left": void 0,
  "top-right": void 0,
  "bottom-left": void 0,
  "bottom-right": void 0
}, Va = (t) => {
  (Pe(t) || Xt(t)) && (t = {
    content: t
  });
  const n = t.placement || t.position || "top", o = hn[n] ? hn[n] : hn[n] = new ka({
    placement: n,
    root: t.root || "body"
  }), e = o.push({
    content: t.content,
    icon: t.icon,
    duration: t.duration || 3e3,
    type: t.type || "normal",
    color: t.color,
    closable: t.closable
  });
  return {
    close: () => o.close(e),
    clear: () => o.clear()
  };
}, tn = Va;
["info", "success", "warning", "error", "loading", "sakura", "normal"].forEach(
  (t) => {
    tn[t] = (n) => ((Pe(n) || Xt(n)) && (n = {
      content: n
    }), tn({
      ...n,
      type: t
    }));
  }
);
const ln = () => {
  const t = R(0);
  function n() {
    ie() && (t.value = window.innerWidth);
  }
  n();
  const o = M(() => {
    let e;
    return t.value <= 576 ? e = xt.XS : t.value <= 768 ? e = xt.SM : t.value <= 992 ? e = xt.MD : t.value <= 1200 ? e = xt.LG : t.value <= 1600 ? e = xt.XL : e = xt.XXL, e;
  });
  return ie() && (window.addEventListener("resize", n), Ue(() => {
    window.removeEventListener("resize", n);
  })), [o, t];
}, $a = { class: "pixelium px-row" }, vo = /* @__PURE__ */ X({
  name: "Row",
  __name: "index",
  props: {
    gutter: { default: 0 },
    justify: { default: "start" },
    align: { default: "start" },
    wrap: { type: Boolean, default: !0 }
  },
  setup(t) {
    const n = t, [o] = ln(), e = M(() => {
      if (he(n.gutter))
        return {
          x: n.gutter,
          y: n.gutter
        };
      if ("x" in n.gutter || "y" in n.gutter)
        return {
          x: n.gutter.x || 0,
          y: n.gutter.y || 0
        };
      const l = n.gutter[o.value];
      return he(l) ? {
        x: l,
        y: l
      } : oo({ x: 0, y: 0 }, l);
    });
    return Ut("px-row-provide", e), (l, a) => (C(), B("div", $a, [
      z("div", {
        class: se(["px-row-inner", {
          [`px-row__justify-${n.justify}`]: !0,
          [`px-row__align-${n.align}`]: !0,
          "px-row__wrap": !!n.wrap
        }]),
        style: oe({
          marginLeft: e.value ? -e.value.x / 2 + "px" : void 0,
          marginRight: e.value ? -e.value.x / 2 + "px" : void 0,
          marginTop: e.value ? -e.value.y / 2 + "px" : void 0,
          marginBottom: e.value ? -e.value.y / 2 + "px" : void 0
        })
      }, [
        ee(l.$slots, "default")
      ], 6)
    ]));
  }
}), Ta = /* @__PURE__ */ X({
  name: "Col",
  __name: "index",
  props: {
    offset: { default: 0 },
    span: { default: 24 }
  },
  setup(t) {
    var u;
    const n = t, [o] = ln(), e = M(() => he(n.offset) ? n.offset : n.offset[o.value] || 0), l = M(() => he(n.span) ? n.span : n.span[o.value] || 24), a = et(), s = R(((u = a == null ? void 0 : a.parent) == null ? void 0 : u.type) === vo).value && Ze("px-row-provide") || R({ x: 0, y: 0 });
    return (f, c) => (C(), B("div", {
      class: se(["pixelium px-col", {
        [`px-col__span-${l.value}`]: !0,
        [`px-col__offset-${e.value}`]: !0
      }]),
      style: oe({
        paddingLeft: V(s) ? V(s).x / 2 + "px" : void 0,
        paddingRight: V(s) ? V(s).x / 2 + "px" : void 0,
        paddingTop: V(s) ? V(s).y / 2 + "px" : void 0,
        paddingBottom: V(s) ? V(s).y / 2 + "px" : void 0
      })
    }, [
      ee(f.$slots, "default")
    ], 6));
  }
}), Ba = /* @__PURE__ */ X({
  name: "Divider",
  __name: "index",
  props: {
    direction: { default: "horizontal" },
    variant: { default: "solid" },
    margin: null,
    size: null
  },
  setup(t) {
    const n = t, o = M(() => {
      if (!Me(n.margin))
        return he(n.margin) ? `${n.margin}px` : n.margin;
    }), e = M(() => {
      if (!Me(n.size))
        return he(n.size) ? `${n.size}px` : n.size;
    });
    return (l, a) => (C(), B("div", {
      class: se(["pixelium px-divider", {
        [`px-divider__${n.direction}`]: !0,
        [`px-divider__${n.variant}`]: !0
      }]),
      style: oe({
        marginLeft: n.direction === "vertical" ? o.value : void 0,
        marginRight: n.direction === "vertical" ? o.value : void 0,
        marginTop: n.direction === "horizontal" ? o.value : void 0,
        marginBottom: n.direction === "horizontal" ? o.value : void 0,
        borderBottomWidth: n.direction === "horizontal" ? e.value : void 0,
        borderRightWidth: n.direction === "vertical" ? e.value : void 0
      })
    }, null, 6));
  }
}), Pa = (t, n) => !!(t && t.shapeFlag & 1), Ia = (t, n) => !!(t && t.shapeFlag & 6), La = (t, n) => !!(t && t.shapeFlag & 8), Ea = (t, n) => !!(t && t.shapeFlag & 16), Aa = (t, n) => !!(t && t.shapeFlag & 32), Da = (t) => t.type === Fo, Ot = (t) => {
  var o, e;
  const n = [];
  for (const l of t ?? [])
    Pa(l) || Ia(l) || La(l) ? n.push(l) : Ea(l, l.children) ? n.push(...Ot(l.children)) : Aa(l, l.children) ? n.push(...Ot((e = (o = l.children).default) == null ? void 0 : e.call(o))) : rt(l) && n.push(...Ot(l));
  return n;
}, Oa = /* @__PURE__ */ X({
  name: "Space",
  __name: "index",
  props: {
    margin: {
      default: "medium"
    },
    direction: {
      default: "horizontal"
    },
    justify: {
      default: "start"
    },
    align: null,
    wrap: {
      type: Boolean,
      default: !0
    },
    inline: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const n = t, o = M(() => n.align ? n.align : n.direction === "horizontal" ? "center" : "stretch"), e = je(), l = M(() => {
      if (!(!n.margin || n.margin === "small" || n.margin === "medium" || n.margin === "large")) {
        if (he(n.margin))
          return {
            x: n.margin,
            y: n.margin
          };
        if ("x" in n.margin || "y" in n.margin) {
          const a = he(n.margin.x) ? n.margin.x : 0, r = he(n.margin.y) ? n.margin.y : 0;
          return {
            x: a,
            y: r
          };
        }
      }
    });
    return () => {
      var r;
      const a = Ot(((r = e.default) == null ? void 0 : r.call(e)) || []);
      return I("div", {
        class: {
          pixelium: !0,
          "px-space": !0,
          "px-space__inline": !!n.inline
        }
      }, [I("div", {
        class: {
          "px-space-inner": !0,
          "px-space__small": n.margin === "small",
          "px-space__large": n.margin === "large",
          [`px-space__justify-${n.justify}`]: !0,
          [`px-space__align-${o.value}`]: !0,
          [`px-space__${n.direction}`]: !0,
          "px-space__wrap": !!n.wrap
        },
        style: {
          marginTop: l.value ? -l.value.y / 2 + "px" : void 0,
          marginBottom: l.value ? -l.value.y / 2 + "px" : void 0,
          marginLeft: l.value ? -l.value.x / 2 + "px" : void 0,
          marginRight: l.value ? -l.value.x / 2 + "px" : void 0
        }
      }, [a.map((s, u) => I(De, {
        key: s.key || `px-space-item-${u}`
      }, [I("div", {
        class: "px-space-item",
        style: {
          marginTop: l.value ? l.value.y / 2 + "px" : void 0,
          marginBottom: l.value ? l.value.y / 2 + "px" : void 0,
          marginLeft: l.value ? l.value.x / 2 + "px" : void 0,
          marginRight: l.value ? l.value.x / 2 + "px" : void 0
        }
      }, [s])]))])]);
    };
  }
}), mo = /* @__PURE__ */ X({
  name: "Grid",
  __name: "index",
  props: {
    column: { default: 24 },
    gutter: { default: 0 }
  },
  setup(t) {
    const n = t, [o] = ln(), e = M(() => {
      if (he(n.gutter))
        return {
          x: n.gutter,
          y: n.gutter
        };
      if ("x" in n.gutter || "y" in n.gutter)
        return {
          x: n.gutter.x || 0,
          y: n.gutter.y || 0
        };
      const r = n.gutter[o.value];
      return he(r) ? {
        x: r,
        y: r
      } : oo({ x: 0, y: 0 }, r);
    }), l = M(() => he(n.column) ? n.column : n.column[o.value] || 24), a = R([]);
    return Ut(io, {
      column: l,
      gutter: e,
      itemsStat: a
    }), kn(ro), (r, s) => (C(), B("div", {
      class: "pixelium px-grid",
      style: oe({
        gridTemplateColumns: `repeat(${l.value}, minmax(0, 1fr))`,
        gap: e.value ? `${e.value.y}px ${e.value.x}px` : void 0
      })
    }, [
      ee(r.$slots, "default")
    ], 4));
  }
}), Na = /* @__PURE__ */ X({
  name: "GridItem",
  __name: "index",
  props: {
    offset: { default: 0 },
    span: null
  },
  setup(t) {
    var i;
    const n = et(), e = R(((i = n == null ? void 0 : n.parent) == null ? void 0 : i.type) === mo).value ? Ze(io) : void 0, l = t, a = Go(), [r] = ut(ro), [s] = ln(), u = M(() => he(l.offset) ? l.offset : l.offset[s.value] || 0), f = M(() => l.span === void 0 ? (e == null ? void 0 : e.column.value) || 24 : he(l.span) ? l.span : l.span[s.value] || 24);
    Re(() => {
      e == null || e.itemsStat.value.push({
        id: a,
        index: r.value,
        offset: u.value,
        span: f.value
      });
    }), we([r, u, f], () => {
      const d = e == null ? void 0 : e.itemsStat.value.find((p) => p.id === a);
      d ? (d.index = r.value, d.offset = u.value, d.span = f.value) : e == null || e.itemsStat.value.push({
        id: a,
        index: r.value,
        offset: u.value,
        span: f.value
      });
    }), Ue(() => {
      const d = e == null ? void 0 : e.itemsStat.value.findIndex((p) => p.id === a);
      d !== void 0 && d > -1 && (e == null || e.itemsStat.value.splice(d, 1));
    });
    const c = M(() => {
      if (!e)
        return;
      if (u.value + f.value > e.column.value)
        return `${u.value + 1} / span ${f.value}`;
      const d = e.itemsStat.value.filter(
        (v) => v.index !== -1 && v.index < r.value
      );
      if (d.length === 0)
        return `${u.value + 1} / span ${f.value}`;
      let p = 0;
      return d.forEach((v) => {
        if (v.span + v.offset >= e.column.value) {
          p = 0;
          return;
        }
        p += v.span + v.offset, p > e.column.value ? p = v.span + v.offset : p === e.column.value && (p = 0);
      }), p + u.value + f.value > e.column.value ? `${u.value + 1} / span ${f.value}` : `${p + u.value + 1} / span ${f.value}`;
    });
    return (d, p) => (C(), B("div", {
      class: "pixelium px-grid-item",
      style: oe({
        gridColumn: c.value
      })
    }, [
      ee(d.$slots, "default")
    ], 4));
  }
}), ho = /* @__PURE__ */ X({
  name: "Container",
  __name: "index",
  props: {
    direction: null
  },
  setup(t) {
    const n = R(0);
    Ut("px-container-provide", n);
    const o = t;
    return (e, l) => (C(), B("section", {
      class: se(["pixelium px-container", {
        "px-container__has-aside": !!n.value,
        [`px-container__${o.direction}`]: !!o.direction
      }])
    }, [
      ee(e.$slots, "default")
    ], 2));
  }
}), Fa = { class: "pixelium px-main" }, Ga = /* @__PURE__ */ X({
  name: "Main",
  __name: "index",
  setup(t) {
    return (n, o) => (C(), B("main", Fa, [
      ee(n.$slots, "default")
    ]));
  }
}), Wa = /* @__PURE__ */ X({
  name: "Aside",
  __name: "index",
  props: {
    width: null,
    bordered: { type: Boolean, default: !1 },
    side: { default: "left" },
    dark: { type: Boolean, default: !1 }
  },
  setup(t) {
    var s;
    const n = et(), e = R(((s = n == null ? void 0 : n.parent) == null ? void 0 : s.type) === ho).value ? Ze("px-container-provide") : void 0;
    Re(() => {
      e && (e.value += 1);
    }), Ue(() => {
      e && (e.value -= 1);
    });
    const l = t, a = Le(), r = M(() => Me(l.width) ? void 0 : he(l.width) ? `${l.width}px` : l.width);
    return (u, f) => (C(), B("aside", {
      class: se(["pixelium px-aside", {
        "px-aside__dark": !V(a) && !!l.dark,
        "px-aside__bordered": !!l.bordered,
        [`px-aside__${l.side}`]: !0
      }]),
      style: oe({
        width: r.value
      })
    }, [
      ee(u.$slots, "default")
    ], 6));
  }
}), Ua = /* @__PURE__ */ X({
  name: "Header",
  __name: "index",
  props: {
    minHeight: null,
    bordered: { type: Boolean },
    dark: { type: Boolean, default: !1 }
  },
  setup(t) {
    const n = t, o = Le(), e = M(() => Me(n.minHeight) ? void 0 : he(n.minHeight) ? `${n.minHeight}px` : n.minHeight);
    return (l, a) => (C(), B("header", {
      class: se(["pixelium px-header", {
        "px-header__dark": !V(o) && !!n.dark,
        "px-header__bordered": !!n.bordered
      }]),
      style: oe({
        minHeight: e.value
      })
    }, [
      ee(l.$slots, "default")
    ], 6));
  }
}), ja = /* @__PURE__ */ X({
  name: "Footer",
  __name: "index",
  props: {
    minHeight: null,
    bordered: { type: Boolean },
    dark: { type: Boolean, default: !1 }
  },
  setup(t) {
    const n = t, o = Le(), e = M(() => Me(n.minHeight) ? void 0 : he(n.minHeight) ? `${n.minHeight}px` : n.minHeight);
    return (l, a) => (C(), B("footer", {
      class: se(["pixelium px-footer", {
        "px-footer__dark": !V(o) && !!n.dark,
        "px-footer__bordered": !!n.bordered
      }]),
      style: oe({
        minHeight: e.value
      })
    }, [
      ee(l.$slots, "default")
    ], 6));
  }
});
// @ts-ignore
typeof process < "u" && process.env.NODE_ENV;
const Xa = "Pixelium";
function Nn(t) {
  throw new Error(`[${Xa}] ${t}`);
}
const yr = (t, n) => {
  var e, l;
  if (!ie())
    return;
  const o = {
    light: [],
    dark: []
  };
  if (Pe(n)) {
    const a = Rt(n);
    o.light = Tt(
      a.r,
      a.g,
      a.b,
      a.a,
      !1
    ).map((r) => j(r)), o.dark = Tt(
      a.r,
      a.g,
      a.b,
      a.a,
      !0
    ).map((r) => j(r));
  } else {
    if ((e = n.light) != null && e.length && n.light.length !== 10)
      return Nn(
        "The length of color.light does not match the required number of CSS color palette (10)."
      );
    if ((l = n.dark) != null && l.length && n.dark.length !== 10)
      return Nn(
        "The length of color.dark does not match the required number of CSS color palette (10)."
      );
    o.light = n.light || [], o.dark = n.dark || [];
  }
  o.light.forEach((a, r) => {
    document.documentElement.style.setProperty(`--px-${t}-light-custom-${r + 1}`, a);
  }), o.dark.forEach((a, r) => {
    document.documentElement.style.setProperty(`--px-${t}-dark-custom-${r + 1}`, a);
  }), Bt.emit(yn);
}, Fn = (t) => {
  if (!ie())
    return;
  const n = document.documentElement;
  n.classList.remove("light", "dark"), t !== "unset" && n.classList.add(t);
};
function qa(t) {
  const n = R(!1);
  if (ie()) {
    let s = function(f) {
      n.value = f.matches;
    };
    const u = window.matchMedia("(prefers-color-scheme: dark)");
    s(u), u.addEventListener("change", s), Ue(() => {
      u.removeEventListener("change", s);
    });
  }
  const o = R(t || n.value ? "dark" : "light");
  t && Fn(o.value);
  const e = () => {
    o.value = o.value === "unset" ? n.value ? "light" : "dark" : o.value === "light" ? "dark" : "light";
  }, l = () => {
    o.value = "unset";
  }, a = () => {
    o.value = n.value ? "dark" : "light";
  }, r = we(o, Fn, { flush: "post" });
  return Wo(() => {
    r();
  }), [o, e, l, a];
}
const Ya = /* @__PURE__ */ X({
  name: "Icon",
  __name: "index",
  props: {
    size: { default: "1em" },
    color: { default: "currentColor" },
    rotate: { default: 0 },
    spin: { type: Boolean, default: !1 },
    flip: { default: "none" }
  },
  setup(t) {
    const n = t, o = M(() => {
      let l = 1, a = 1;
      return (n.flip === "horizontal" || n.flip === "both") && (l = -1), (n.flip === "vertical" || n.flip === "both") && (a = -1), `scale(${l}, ${a}) rotate(${n.rotate}deg)`;
    }), e = M(() => he(n.size) ? `${n.size}px` : n.size);
    return (l, a) => (C(), B("div", {
      class: se({
        "pixelium px-icon": !0,
        "px-animation__loading": !!n.spin
      }),
      style: oe({
        height: e.value,
        width: e.value,
        fontSize: e.value,
        color: n.color,
        transform: o.value
      })
    }, [
      ee(l.$slots, "default")
    ], 6));
  }
}), Ka = (t, n, o, e, l, a, r, s, u, f, c) => {
  t.fillStyle = j(r);
  for (let i = 0; i < 4; i++)
    l[i] <= s || (!(i === 1 || i === 2) || u && c || !u) && Fe(
      t,
      e[i][0],
      e[i][1],
      l[i],
      a[i][0],
      a[i][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(e[0][0], 0, e[1][0] - e[0][0] + s, s), e[2][1] + s > e[1][1] && (u && c || !u) && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0],
    o - s,
    e[2][0] - e[3][0] + s,
    s
  ), e[3][1] + s > e[0][1] && !(u && !f) && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s), u && !f && t.fillRect(s / 2, 0, s / 2, o), u && !c && t.fillRect(n - 2 * s - 1, 0, s, o);
};
function It({ afterComposition: t }) {
  const n = R(!1);
  return [n, (l) => {
    n.value = !0;
  }, (l) => {
    n.value && (n.value = !1, ae(() => t(l)));
  }];
}
const Qa = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M16 11h1v2h-1zM16 13v2h-1v1h-2v-1h1v-1h1v-1zM16 9v2h-1v-1h-1V9h-1V8h2v1zM11 16h2v1h-2zM11 15v1H9v-1H8v-2h1v1h1v1zM13 7v1h-1v3h-1v1H8v1H7v-2h1V9h1V8h2V7z" }, null, -1),
      z("path", { d: "M22 11V9h-1V8h-1V7h-1V6h-2V5H7v1H5v1H4v1H3v1H2v2H1v2h1v2h1v1h1v1h1v1h2v1h10v-1h2v-1h1v-1h1v-1h1v-2h1v-2zm-1 3h-1v1h-1v1h-1v1h-2v1H8v-1H7v-1H5v-1H4v-1H3v-4h1V9h1V8h1V7h2V6h8v1h2v1h1v1h1v1h1z" }, null, -1)
    ])], 4));
  }
}), Ja = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M15 13h1v2h-1v1h-2v-1h1v-1h1zM16 11h1v2h-1z" }, null, -1),
      z("path", { d: "M23 11v2h-1v2h-1v1h-1v1h-1v1h-2v1H9v-1h7v-1h2v-1h1v-1h1v-1h1v-4h-1V9h-1V8h2v1h1v2zM2 13H1v-2h1V9h1V8h1V7h1V6h2V5h8v1H8v1H6v1H5v1H4v1H3v4h1v1h1v1H3v-1H2z" }, null, -1),
      z("path", { d: "M13 7v1h-1v1h-1v1h-1v1H9v1H8v1H7v-2h1V9h1V8h2V7zM9 17H8v1H7v1H6v1H5v1H4v1H3v-1H2v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1V9h1V8h1V7h1V6h1V5h1V4h1V3h1V2h1v1h1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1H9zM11 16h2v1h-2z" }, null, -1)
    ])], 4));
  }
}), mt = (t, n, o, e) => {
  const l = M(() => n[t] !== void 0), a = l.value ? n[t] : e != null && e.defaultField ? n[e.defaultField] : null, r = R(e != null && e.transform ? e == null ? void 0 : e.transform(a) : a), s = async (u) => {
    l.value ? (o(`update:${t}`, u), await ae(), r.value = e != null && e.transform ? e == null ? void 0 : e.transform(n[t]) : n[t]) : r.value = e != null && e.transform ? e == null ? void 0 : e.transform(u) : u;
  };
  return we(
    () => n[t],
    (u) => {
      r.value = e != null && e.transform ? e == null ? void 0 : e.transform(u) : u;
    }
  ), [r, s, l];
}, Za = {
  key: 0,
  class: "px-input-prefix-wrapper"
}, Sa = ["value", "placeholder", "disabled", "autofocus", "type"], za = {
  key: 1,
  class: "px-input-close-wrapper"
}, el = {
  key: 1,
  class: "px-input-icon-placeholder"
}, tl = {
  key: 2,
  class: "px-input-password-wrapper"
}, nl = {
  key: 3,
  class: "px-input-count-wrapper"
}, ol = {
  key: 4,
  class: "px-input-loading-wrapper"
}, al = {
  key: 5,
  class: "px-input-suffix-wrapper"
}, ll = /* @__PURE__ */ X({
  name: "Input",
  __name: "index",
  props: {
    modelValue: null,
    defaultValue: null,
    placeholder: null,
    password: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    clearable: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    size: { default: "medium" },
    shape: { default: "default" },
    borderRadius: null,
    maxLength: null,
    showCount: { type: Boolean, default: !1 },
    countGraphemes: { type: Function },
    sliceGraphemes: { type: Function },
    status: { default: "normal" },
    autofocus: { type: Boolean },
    nativeType: null
  },
  emits: ["input", "update:modelValue", "change", "clear", "blur", "focus"],
  setup(t, { expose: n, emit: o }) {
    var re;
    const e = t, l = o, [a, r, s] = It({
      afterComposition: (J) => {
        ae(() => {
          L(J);
        });
      }
    }), u = et(), f = R(((re = u == null ? void 0 : u.parent) == null ? void 0 : re.type) === wt), [c, i, d] = f.value ? ut(yt) : [R(0), R(!1), R(!1)], p = Ze(bt), m = M(() => f.value && p ? p.borderRadius : e.borderRadius), v = M(() => f.value && p ? p.size : e.size), h = M(() => f.value && p ? p.shape : e.shape), w = M(() => f.value && p && p.disabled || e.disabled), [y, g] = mt("modelValue", e, l, {
      defaultField: "defaultValue",
      transform: (J) => J || ""
    }), _ = S(null), x = S(null), k = S(null), H = M(() => e.countGraphemes ? e.countGraphemes(y.value) : y.value.length), L = async (J) => {
      let me = J.target.value;
      y.value = me, !a.value && (l("input", me, J), e.maxLength && (e.countGraphemes && e.sliceGraphemes ? (await ae(), me = e.sliceGraphemes(y.value, e.maxLength)) : me = y.value.slice(0, e.maxLength)), g(me));
    }, E = async () => {
      await g(""), l("change", ""), l("clear", "");
    }, G = (J) => {
      const ye = J.target;
      l("change", ye.value, J);
    }, D = R(!1), U = () => {
      D.value = !1;
    }, A = () => {
      D.value = !0;
    }, F = () => {
      var J;
      (J = k.value) == null || J.focus();
    }, K = R(!1), ne = () => {
      K.value = !0;
    }, O = () => {
      K.value = !1;
    }, Q = M(() => e.clearable && !w.value && !e.readonly), W = R(!1), _e = () => {
      W.value = !W.value;
    }, pe = M(() => e.nativeType ? e.nativeType : e.password ? W.value ? "text" : "password" : "text"), be = je();
    n({
      focus: () => {
        var J;
        (J = k.value) == null || J.focus();
      },
      blur: () => {
        var J;
        (J = k.value) == null || J.blur();
      },
      clear: () => E(),
      select: () => {
        var J;
        (J = k.value) == null || J.select();
      }
    });
    const ce = Le();
    we(
      [
        i,
        d,
        m,
        h,
        v,
        w,
        () => be,
        ce,
        D,
        K
      ],
      () => {
        setTimeout(() => {
          ve();
        });
      }
    );
    const ve = () => {
      const J = Xe(_, x);
      if (!J)
        return;
      const { ctx: ye, width: me, height: $e, canvas: q } = J, T = Ne(), Y = gt(
        q,
        T,
        m.value,
        h.value,
        v.value || "medium",
        f.value,
        i.value,
        d.value
      ), te = e.status !== "normal" ? b(e.status === "error" ? "danger" : e.status, 6) : (K.value || D.value) && !w.value && !e.readonly ? b("primary", 6) : b("neutral", 10), fe = ft(Y, me, $e, T);
      Ka(
        ye,
        me,
        $e,
        fe,
        Y,
        it,
        te,
        T,
        f.value,
        i.value,
        d.value
      );
      const He = w.value ? b("neutral", 6) : b("neutral", 1);
      ct(ye, Math.round(me / 2), Math.round($e / 2), He);
    };
    return Re(() => {
      ae(() => {
        ve();
      });
    }), We(_, ve), qe(ve), (J, ye) => (C(), B("div", {
      class: se(["pixelium px-input", {
        [`px-input__${v.value}`]: !!v.value,
        [`px-input__${h.value}`]: !!h.value,
        "px-input__inner": f.value,
        "px-input__disabled": !!w.value
      }]),
      ref_key: "wrapperRef",
      ref: _,
      onClick: F,
      onMouseenter: ne,
      onMouseleave: O
    }, [
      V(be).prefix ? (C(), B("div", Za, [
        ee(J.$slots, "prefix")
      ])) : ue("", !0),
      z("input", {
        class: "px-input-inner",
        value: V(y),
        ref_key: "inputRef",
        ref: k,
        placeholder: e.placeholder,
        disabled: w.value || e.readonly,
        autofocus: t.autofocus,
        type: pe.value,
        onInput: vt(L, ["stop"]),
        onChange: vt(G, ["stop"]),
        onBlur: U,
        onFocus: A,
        onCompositionstart: ye[0] || (ye[0] = //@ts-ignore
        (...me) => V(r) && V(r)(...me)),
        onCompositionend: ye[1] || (ye[1] = //@ts-ignore
        (...me) => V(s) && V(s)(...me))
      }, null, 40, Sa),
      Q.value ? (C(), B("div", za, [
        K.value && V(y) ? (C(), Ve(V(Ht), {
          key: 0,
          class: "px-input-icon",
          onClick: E
        })) : (C(), B("div", el))
      ])) : ue("", !0),
      e.password ? (C(), B("div", tl, [
        W.value ? (C(), Ve(V(Ja), {
          key: 1,
          class: "px-input-icon",
          onClick: _e
        })) : (C(), Ve(V(Qa), {
          key: 0,
          class: "px-input-icon",
          onClick: _e
        }))
      ])) : ue("", !0),
      e.showCount ? (C(), B("div", nl, [
        ee(J.$slots, "count", {
          value: V(y),
          count: H.value,
          maxLength: e.maxLength
        }, () => [
          z("span", null, Ae(H.value) + Ae(V(Me)(e.maxLength) ? "" : " / " + e.maxLength), 1)
        ])
      ])) : ue("", !0),
      e.loading ? (C(), B("div", ol, [
        I(V(ot), { class: "px-input-icon px-animation__loading" })
      ])) : ue("", !0),
      V(be).suffix ? (C(), B("div", al, [
        ee(J.$slots, "suffix")
      ])) : ue("", !0),
      z("canvas", {
        class: "px-input-canvas",
        ref_key: "canvasRef",
        ref: x
      }, null, 512)
    ], 34));
  }
}), sl = (t, n, o, e, l, a, r, s, u, f, c) => {
  t.fillStyle = j(r);
  for (let i = 0; i < 4; i++)
    l[i] <= s || (!(i === 1 || i === 2) || u && c || !u) && Fe(
      t,
      e[i][0],
      e[i][1],
      l[i],
      a[i][0],
      a[i][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(e[0][0], 0, e[1][0] - e[0][0] + s, s), e[2][1] + s > e[1][1] && (u && c || !u) && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0],
    o - s,
    e[2][0] - e[3][0] + s,
    s
  ), e[3][1] + s > e[0][1] && !(u && !f) && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s), u && !f && t.fillRect(s / 2, 0, s / 2, o), u && !c && t.fillRect(n - 2 * s - 1, 0, s, o);
}, Gn = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M1 11h22v2H1z" }, null, -1)
    ])], 4));
  }
}), Wn = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M23 11v2H13v10h-2V13H1v-2h10V1h2v10z" }, null, -1)
    ])], 4));
  }
}), rl = {
  key: 0,
  class: "px-input-number-prefix-wrapper"
}, ul = ["value", "placeholder", "disabled", "autofocus"], il = {
  key: 2,
  class: "px-input-number-close-wrapper"
}, cl = {
  key: 1,
  class: "px-input-number-icon-placeholder"
}, fl = {
  key: 4,
  class: "px-input-number-loading-wrapper"
}, dl = {
  key: 5,
  class: "px-input-number-suffix-wrapper"
}, pl = /* @__PURE__ */ X({
  name: "InputNumber",
  __name: "index",
  props: {
    modelValue: null,
    defaultValue: null,
    placeholder: null,
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    max: { default: Number.MAX_SAFE_INTEGER },
    min: { default: Number.MIN_SAFE_INTEGER },
    step: { default: 1 },
    precision: null,
    strickStep: { type: Boolean, default: !1 },
    format: { type: Function },
    allowInput: { type: Function },
    parse: { type: Function },
    clearable: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    size: { default: "medium" },
    shape: { default: "default" },
    borderRadius: null,
    buttonPlacement: { default: "end" },
    status: { default: "normal" },
    autofocus: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "change", "clear", "blur", "focus"],
  setup(t, { expose: n, emit: o }) {
    var lt;
    const e = t, l = o, a = et(), r = R(((lt = a == null ? void 0 : a.parent) == null ? void 0 : lt.type) === wt), [s, u, f] = r.value ? ut(yt) : [R(0), R(!1), R(!1)], c = Ze(bt), i = M(() => r.value && c ? c.borderRadius : e.borderRadius), d = M(() => r.value && c ? c.size : e.size), p = M(() => r.value && c ? c.shape : e.shape), m = M(() => r.value && c && c.disabled || e.disabled), v = /^[+-]?\d+(?:\.\d*)?$/, h = ($) => {
      fn($) && ($ = 0), he(e.precision) && ($ = parseFloat($.toFixed(Dt(Math.round(e.precision), 0, 100))));
      const le = e.min ?? Number.MIN_SAFE_INTEGER, Ce = e.max ?? Number.MAX_SAFE_INTEGER;
      if ($ = Dt($, le, Ce), e.strickStep && !Zo(e.step) && !fn(e.step) && e.step !== 0) {
        let Te = Math.round($ / e.step) * e.step;
        Te < le && (Te = Math.ceil($ / e.step) * e.step), Te > Ce && (Te = Math.floor($ / e.step) * e.step), $ = Te;
      }
      return $;
    }, w = ($) => e.format ? e.format($) : fn($) || Me($) ? "" : he(e.precision) ? $.toFixed(Dt(Math.round(e.precision), 0, 100)) : $ + "", y = ($) => e.allowInput ? e.allowInput($) : $.length ? v.test($) : !0, g = ($) => e.parse ? e.parse($) : $.length ? parseFloat($) : 0, [_, x] = mt("modelValue", e, l, {
      defaultField: "defaultValue",
      transform: ($) => {
        if (!Me($)) {
          const le = h($);
          return le !== $ && l("update:modelValue", le), le;
        }
        return $;
      }
    }), k = R(w(_.value)), [H, L, E] = It({
      afterComposition: ($) => {
        ae(() => {
          F($);
        });
      }
    }), G = S(null), D = S(null), U = S(null), A = ($) => {
      k.value = $;
    };
    we(_, ($) => {
      O.value || A(w($));
    });
    const F = async ($) => {
      const Ce = $.target.value;
      if (H.value)
        return;
      if (!y(Ce)) {
        U.value && (U.value.value = k.value);
        return;
      }
      k.value = Ce;
      const Te = h(g(Ce));
      l("input", Te, $), await x(Te);
    }, K = async () => {
      const $ = h(0);
      await x($), A(w(_.value)), l("change", $), l("clear", $);
    }, ne = ($) => {
      const le = $.target, Ce = g(le.value);
      A(w(_.value)), l("change", Ce, $);
    }, O = R(!1), Q = () => {
      A(w(_.value)), O.value = !1;
    }, W = () => {
      O.value = !0;
    }, _e = M(() => e.clearable && !m.value && !e.readonly), pe = je();
    n({
      focus: () => {
        var $;
        ($ = U.value) == null || $.focus();
      },
      blur: () => {
        var $;
        ($ = U.value) == null || $.blur();
      },
      clear: () => K(),
      select: () => {
        var $;
        ($ = U.value) == null || $.select();
      }
    });
    const be = M(() => e.readonly || m.value || _.value && _.value >= e.max), ce = M(() => e.readonly || m.value || _.value && _.value <= e.min), ve = async () => {
      if (be.value)
        return;
      let $ = _.value;
      Me($) && ($ = h(0));
      const le = h($ + e.step);
      await x(le), A(w(_.value));
    }, re = async () => {
      if (ce.value)
        return;
      let $ = _.value;
      Me($) && ($ = h(0));
      const le = h($ - e.step);
      await x(le), A(w(_.value));
    }, J = M(() => e.buttonPlacement === "both" || e.buttonPlacement === "both-reverse" || e.buttonPlacement === "end" || e.buttonPlacement === "end-reverse"), ye = M(() => e.buttonPlacement === "both-reverse" || e.buttonPlacement === "end" || e.buttonPlacement === "end-reverse"), me = M(() => e.buttonPlacement === "both" || e.buttonPlacement === "end" || e.buttonPlacement === "end-reverse"), $e = M(() => e.buttonPlacement === "both" || e.buttonPlacement === "both-reverse" || e.buttonPlacement === "start" || e.buttonPlacement === "start-reverse"), q = M(() => e.buttonPlacement === "both" || e.buttonPlacement === "start" || e.buttonPlacement === "start-reverse"), T = M(() => e.buttonPlacement === "both-reverse" || e.buttonPlacement === "start" || e.buttonPlacement === "start-reverse"), Y = ($) => {
      $.detail > 1 && $.preventDefault();
    }, te = () => {
      var $;
      ($ = U.value) == null || $.focus();
    }, fe = R(!1), de = () => {
      fe.value = !0;
    }, He = () => {
      fe.value = !1;
    }, at = Le();
    we(
      [
        () => e.status,
        i,
        p,
        d,
        m,
        () => pe,
        u,
        f,
        at,
        fe,
        O
      ],
      () => {
        setTimeout(() => {
          Ye();
        });
      }
    );
    const Ye = () => {
      const $ = Xe(G, D);
      if (!$)
        return;
      const { ctx: le, width: Ce, height: Te, canvas: Qt } = $, kt = Ne(), P = gt(
        Qt,
        kt,
        i.value,
        p.value,
        d.value || "medium",
        r.value,
        u.value,
        f.value
      ), N = e.status !== "normal" ? b(e.status === "error" ? "danger" : e.status, 6) : (fe.value || O.value) && !m.value && !e.readonly ? b("primary", 6) : b("neutral", 10), Z = ft(P, Ce, Te, kt);
      sl(
        le,
        Ce,
        Te,
        Z,
        P,
        it,
        N,
        kt,
        r.value,
        u.value,
        f.value
      );
      const Ee = m.value ? b("neutral", 6) : b("neutral", 1);
      ct(le, Math.round(Ce / 2), Math.round(Te / 2), Ee);
    };
    return Re(() => {
      ae(() => {
        Ye();
      });
    }), We(G, Ye), qe(Ye), ($, le) => (C(), B("div", {
      class: se(["pixelium px-input-number", {
        [`px-input-number__${d.value}`]: !!d.value,
        [`px-input-number__${p.value}`]: !!p.value,
        "px-input-number__inner": r.value,
        "px-input-number__disabled": !!m.value
      }]),
      ref_key: "wrapperRef",
      ref: G,
      onClick: te,
      onMouseenter: de,
      onMouseleave: He
    }, [
      V(pe).prefix ? (C(), B("div", rl, [
        ee($.$slots, "prefix")
      ])) : ue("", !0),
      $e.value ? (C(), B("div", {
        key: 1,
        class: se([
          "px-input-number-setting-prefix-wrapper",
          e.buttonPlacement === "start-reverse" && "px-input-number-setting-prefix-wrapper__reverse"
        ])
      }, [
        q.value ? (C(), Ve(V(Wn), {
          key: 0,
          class: se(["px-input-number-icon", be.value && "px-input-number-icon__disabled"]),
          onClick: ve,
          onMousedown: Y
        }, null, 8, ["class"])) : ue("", !0),
        T.value ? (C(), Ve(V(Gn), {
          key: 1,
          class: se(["px-input-number-icon", ce.value && "px-input-number-icon__disabled"]),
          onClick: re,
          onMousedown: Y
        }, null, 8, ["class"])) : ue("", !0)
      ], 2)) : ue("", !0),
      z("input", {
        class: "px-input-number-inner",
        value: k.value,
        ref_key: "inputRef",
        ref: U,
        placeholder: e.placeholder,
        disabled: m.value || e.readonly,
        autofocus: t.autofocus,
        onInput: vt(F, ["stop"]),
        onChange: vt(ne, ["stop"]),
        onBlur: Q,
        onFocus: W,
        onCompositionstart: le[0] || (le[0] = //@ts-ignore
        (...Ce) => V(L) && V(L)(...Ce)),
        onCompositionend: le[1] || (le[1] = //@ts-ignore
        (...Ce) => V(E) && V(E)(...Ce))
      }, null, 40, ul),
      _e.value ? (C(), B("div", il, [
        fe.value && k.value ? (C(), Ve(V(Ht), {
          key: 0,
          class: "px-input-number-icon",
          onClick: K
        })) : (C(), B("div", cl))
      ])) : ue("", !0),
      J.value ? (C(), B("div", {
        key: 3,
        class: se([
          "px-input-number-setting-suffix-wrapper",
          e.buttonPlacement === "end-reverse" && "px-input-number-setting-suffix-wrapper__reverse"
        ])
      }, [
        ye.value ? (C(), Ve(V(Wn), {
          key: 0,
          class: se(["px-input-number-icon", be.value && "px-input-number-icon__disabled"]),
          onClick: ve,
          onMousedown: Y
        }, null, 8, ["class"])) : ue("", !0),
        me.value ? (C(), Ve(V(Gn), {
          key: 1,
          class: se(["px-input-number-icon", ce.value && "px-input-number-icon__disabled"]),
          onClick: re,
          onMousedown: Y
        }, null, 8, ["class"])) : ue("", !0)
      ], 2)) : ue("", !0),
      e.loading ? (C(), B("div", fl, [
        I(V(ot), { class: "px-input-number-icon px-animation__loading" })
      ])) : ue("", !0),
      V(pe).suffix ? (C(), B("div", dl, [
        ee($.$slots, "suffix")
      ])) : ue("", !0),
      z("canvas", {
        class: "px-input-number-canvas",
        ref_key: "canvasRef",
        ref: D
      }, null, 512)
    ], 34));
  }
}), vl = (t, n, o, e, l, a) => {
  t.fillStyle = j(e), t.fillRect(a, 0, n - 2 * a, a), t.fillRect(n - a, a, a, o - 2 * a), t.fillRect(a, o - a, n - 2 * a, a), t.fillRect(0, a, a, o - 2 * a), t.fillStyle = j(l), t.fillRect(a, a, n - 2 * a, o - 2 * a);
};
let Qe = null;
const ml = `
  position:absolute!important;
  top:-9999px!important;
  left:-9999px!important;
  overflow:hidden!important;
  opacity:0!important;
  pointer-events:none!important;
  width:{width}px!important;
  min-height:0!important;
  height:0!important;
  z-index:-9999!important;
`, hl = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "font-variant",
  "text-rendering",
  "text-transform",
  "width",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function gl(t) {
  const n = window.getComputedStyle(t), o = n.getPropertyValue("box-sizing"), e = parseFloat(n.getPropertyValue("padding-top")) + parseFloat(n.getPropertyValue("padding-bottom")), l = parseFloat(n.getPropertyValue("border-top-width")) + parseFloat(n.getPropertyValue("border-bottom-width"));
  return { sizingStyle: hl.map(
    (r) => `${r}:${n.getPropertyValue(r)}`
  ).join(";"), paddingSize: e, borderSize: l, boxSizing: o };
}
function yl(t, n = 1, o = 1 / 0) {
  Qe || (Qe = document.createElement("textarea"), document.body.appendChild(Qe));
  const { sizingStyle: e, paddingSize: l, borderSize: a, boxSizing: r } = gl(t), s = t.getBoundingClientRect().width;
  Qe.setAttribute(
    "style",
    `${e};${Ko(ml, (d) => d === "width" ? String(s) : "")}`
  ), Qe.value = "";
  let u = Qe.scrollHeight - l;
  const f = u * n + (r === "border-box" ? l + a : 0), c = u * o + (r === "border-box" ? l + a : 0);
  Qe.value = t.value || t.placeholder || "";
  let i = Qe.scrollHeight;
  return i += +(r === "border-box") * a, i = Dt(i, f, c), {
    height: i,
    minHeight: f,
    maxHeight: c
  };
}
let wn = 0;
function bl(t, n, o) {
  return yl(t, n, o);
}
function wl() {
  wn--, Qe && wn <= 0 && (Qe.remove(), Qe = null);
}
function _l() {
  wn++;
}
const xl = (t, n) => {
  const o = R(void 0), e = R(void 0), l = R(void 0), a = () => {
    if (ie() && t.value) {
      const r = bl(
        t.value,
        n.minRows || 1,
        n.maxRows || 1 / 0
      );
      o.value = r.height, l.value = r.maxHeight, e.value = r.minHeight;
    }
  };
  return ie() && (_l(), We(t, a, !0), Ue(() => {
    wl();
  })), [o, e, l, a];
}, Cl = ["value", "placeholder", "disabled", "autofocus", "rows"], Ml = { class: "px-textarea-addition-wrapper" }, Rl = {
  key: 0,
  class: "px-textarea-close-wrapper"
}, Hl = {
  key: 1,
  class: "px-textarea-count-wrapper"
}, kl = {
  key: 2,
  class: "px-textarea-loading-wrapper"
}, Vl = /* @__PURE__ */ X({
  name: "Textarea",
  __name: "index",
  props: {
    modelValue: null,
    defaultValue: null,
    rows: null,
    minRows: { default: 1 },
    maxRows: { default: 1 / 0 },
    autoResize: { type: Boolean, default: !1 },
    resize: { type: Boolean, default: !0 },
    placeholder: null,
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    clearable: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    size: { default: "medium" },
    maxLength: null,
    showCount: { type: Boolean, default: !1 },
    countGraphemes: { type: Function },
    sliceGraphemes: { type: Function },
    status: { default: "normal" },
    autofocus: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "change", "clear", "blur", "focus"],
  setup(t, { expose: n, emit: o }) {
    const e = t, l = o, [a, r, s] = It({
      afterComposition: (O) => {
        ae(() => {
          y(O);
        });
      }
    }), [u, f] = mt("modelValue", e, l, {
      defaultField: "defaultValue",
      transform: (O) => O || ""
    }), c = S(null), i = S(null), d = S(null), [p, m, v, h] = xl(d, e), w = M(() => u.value ? e.countGraphemes ? e.countGraphemes(u.value) : u.value.length : 0), y = async (O) => {
      let W = O.target.value;
      u.value = W, !a.value && (e.maxLength && (e.countGraphemes && e.sliceGraphemes ? (await ae(), W = e.sliceGraphemes(W, e.maxLength)) : W = W.slice(0, e.maxLength)), u.value = W, l("input", W, O), f(W));
    }, g = async () => {
      await f(""), l("change", ""), l("clear", "");
    }, _ = (O) => {
      const Q = O.target;
      h(), l("change", Q.value, O);
    }, x = R(!1), k = () => {
      e.autoResize && d.value && p.value && (d.value.style.height = p.value + "px");
    };
    we(p, () => {
      k();
    });
    const H = () => {
      k(), x.value = !1;
    }, L = () => {
      k(), x.value = !0;
    }, E = M(() => e.clearable && x.value && !e.disabled && !e.readonly && !!u.value), G = () => {
      var O;
      (O = d.value) == null || O.focus();
    }, D = R(!1), U = () => {
      D.value = !0;
    }, A = () => {
      D.value = !1;
    };
    n({
      focus: () => {
        var O;
        (O = d.value) == null || O.focus();
      },
      blur: () => {
        var O;
        (O = d.value) == null || O.blur();
      },
      clear: () => g(),
      select: () => {
        var O;
        (O = d.value) == null || O.select();
      }
    });
    const F = Le();
    we([() => e.size, () => e.disabled, F, D, x], () => {
      setTimeout(() => {
        ne();
      });
    });
    const K = () => {
      const O = Xe(c, i);
      if (!O)
        return;
      const { ctx: Q, width: W, height: _e } = O, pe = Ne(), be = e.status !== "normal" ? b(e.status === "error" ? "danger" : e.status, 6) : (D.value || x.value) && !e.disabled && !e.readonly ? b("primary", 6) : b("neutral", 10), ce = e.disabled ? b("neutral", 6) : b("neutral", 1);
      vl(Q, W, _e, be, ce, pe);
    }, ne = So(K, 0, {
      maxWait: 50
    });
    return Re(() => {
      ae(() => {
        K();
      }), setTimeout(() => {
        k();
      });
    }), We(c, ne), qe(ne), (O, Q) => (C(), B("div", {
      class: se(["pixelium px-textarea", {
        [`px-textarea__${e.size}`]: !!e.size,
        "px-textarea__disabled": !!e.disabled,
        "px-textarea__resize": !!e.resize
      }]),
      ref_key: "wrapperRef",
      ref: c,
      onClick: G,
      onMouseenter: U,
      onMouseleave: A
    }, [
      z("textarea", {
        class: "px-textarea-inner",
        value: V(u),
        ref_key: "inputRef",
        ref: d,
        placeholder: e.placeholder,
        disabled: e.disabled || e.readonly,
        autofocus: t.autofocus,
        rows: e.rows,
        style: oe({
          minHeight: V(m) ? V(m) + "px" : void 0,
          maxHeight: V(v) ? V(v) + "px" : void 0
        }),
        onInput: vt(y, ["stop"]),
        onChange: vt(_, ["stop"]),
        onBlur: H,
        onFocus: L,
        onCompositionstart: Q[0] || (Q[0] = //@ts-ignore
        (...W) => V(r) && V(r)(...W)),
        onCompositionend: Q[1] || (Q[1] = //@ts-ignore
        (...W) => V(s) && V(s)(...W))
      }, null, 44, Cl),
      z("div", Ml, [
        E.value ? (C(), B("div", Rl, [
          I(V(Ht), {
            class: "px-textarea-icon",
            onClick: g
          })
        ])) : ue("", !0),
        e.showCount ? (C(), B("div", Hl, [
          ee(O.$slots, "count", {
            value: V(u),
            count: w.value,
            maxLength: e.maxLength
          }, () => [
            z("span", null, Ae(w.value) + Ae(V(Me)(e.maxLength) ? "" : " / " + e.maxLength), 1)
          ])
        ])) : ue("", !0),
        e.loading ? (C(), B("div", kl, [
          I(V(ot), { class: "px-textarea-icon px-animation__loading" })
        ])) : ue("", !0)
      ]),
      z("canvas", {
        class: "px-textarea-canvas",
        ref_key: "canvasRef",
        ref: i
      }, null, 512)
    ], 34));
  }
});
function $l(t, n, o = "primary", e) {
  if (e)
    switch (n) {
      case "outline":
        return ke;
      case "plain":
        return e[0];
      default:
        return t ? e[1] : e[5];
    }
  else if (o !== "info")
    switch (n) {
      case "outline":
        return ke;
      case "plain":
        return b(o, 1);
      default:
        return t ? b(o, 2) : b(o, 6);
    }
  else
    switch (n) {
      case "outline":
        return ke;
      case "plain":
        return b("neutral", 1);
      default:
        return t ? b("neutral", 7) : b("neutral", 8);
    }
}
function Tl(t, n, o = "primary", e) {
  if (e)
    switch (n) {
      case "plain":
        return e[1];
      case "outline":
        return t ? e[0] : e[5];
      default:
        return t ? e[0] : e[4];
    }
  else if (o !== "info")
    switch (n) {
      case "plain":
        return b(o, 2);
      case "outline":
        return t ? b(o, 1) : b(o, 6);
      default:
        return t ? b(o, 1) : b(o, 5);
    }
  else {
    switch (n) {
      case "plain":
        return t ? b("neutral", 5) : b("neutral", 7);
      case "outline":
        return t ? b("neutral", 7) : b("neutral", 9);
    }
    return t ? b("neutral", 5) : b("neutral", 7);
  }
}
const Bl = (t, n, o, e, l, a, r, s) => {
  t.fillStyle = j(r);
  for (let u = 0; u < 4; u++)
    l[u] > s && Fe(
      t,
      e[u][0],
      e[u][1],
      l[u],
      a[u][0],
      a[u][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(e[0][0], 0, e[1][0] - e[0][0] + s, s), e[2][1] + s > e[1][1] && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0],
    o - s,
    e[2][0] - e[3][0] + s,
    s
  ), e[3][1] + s > e[0][1] && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s);
}, Pl = (t, n, o) => {
  if (!(!t || n === "primary")) {
    if (o)
      return j(n === "plain" ? t[2] : t[1]);
    switch (n) {
      case "outline":
        return j(t[5]);
      case "plain":
        return j(t[5]);
      default:
        return;
    }
  }
}, Il = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-hn",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", { d: "M14 13h1v1h1v1h1v1h1v1h1v1h1v1h1v1h1v1h-1v1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-1v-1h-2v1h-1v1H9v1H8v1H7v1H6v1H5v1H4v1H3v-1H2v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-1h1v-2H9v-1H8V9H7V8H6V7H5V6H4V5H3V4H2V3h1V2h1v1h1v1h1v1h1v1h1v1h1v1h1v1h1v1h2V9h1V8h1V7h1V6h1V5h1V4h1V3h1V2h1v1h1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1v1h-1z" }, null, -1)
    ])], 4));
  }
}), Ll = {
  key: 0,
  class: "px-tag-icon-wrapper"
}, st = /* @__PURE__ */ X({
  name: "Tag",
  __name: "index",
  props: {
    borderRadius: null,
    shape: { default: "default" },
    size: { default: "medium" },
    disabled: { type: Boolean, default: !1 },
    variant: { default: "primary" },
    theme: { default: "primary" },
    color: null,
    closable: { type: Boolean }
  },
  emits: ["close"],
  setup(t, { emit: n }) {
    const o = t, e = n, l = R(!1), a = R(!1), r = (v) => {
      l.value = v;
    }, s = (v) => {
      a.value = v;
    }, u = Le(), f = S(null), c = S(null);
    Re(() => {
      ae(() => {
        m();
      });
    });
    const i = M(() => {
      if (!o.color) return null;
      const v = Rt(o.color);
      return Tt(v.r, v.g, v.b, v.a, u.value);
    }), d = M(() => Pl(i.value, o.variant, o.disabled)), p = (v) => {
      o.disabled || e("close", v);
    };
    we(
      [
        () => o.borderRadius,
        () => o.shape,
        () => o.disabled,
        () => o.variant,
        () => o.theme,
        i,
        u
      ],
      () => {
        m();
      }
    );
    const m = () => {
      const v = Xe(c, f);
      if (!v)
        return;
      const { ctx: h, width: w, height: y, canvas: g } = v, _ = Ne(), x = gt(
        g,
        _,
        o.borderRadius,
        o.shape,
        "medium",
        !1,
        !1,
        !1
      ), k = Tl(o.disabled, o.variant, o.theme, i.value), H = ft(x, w, y, _);
      Bl(h, w, y, H, x, it, k, _);
      const E = $l(
        o.disabled,
        o.variant,
        o.theme,
        i.value
      );
      ct(h, Math.round(w / 2), Math.round(y / 2), E);
    };
    return We(c, m), qe(m), (v, h) => (C(), B("span", {
      class: se(["pixelium px-tag", {
        "px-tag__large": o.size === "large",
        "px-tag__small": o.size === "small",
        "px-tag__outline": o.variant === "outline",
        "px-tag__plain": o.variant === "plain",
        "px-tag__disabled": o.disabled,
        "px-tag__custom": i.value,
        [`px-tag__${o.theme || "primary"}`]: !0
      }]),
      style: oe({
        color: d.value
      }),
      ref_key: "tagRef",
      ref: c
    }, [
      z("canvas", {
        ref_key: "canvasRef",
        ref: f,
        class: "px-tag-canvas"
      }, null, 512),
      ee(v.$slots, "default"),
      o.closable ? (C(), B("div", Ll, [
        I(V(Il), {
          onMousedown: h[0] || (h[0] = (w) => s(!0)),
          onMouseup: h[1] || (h[1] = (w) => s(!1)),
          onMouseenter: h[2] || (h[2] = (w) => r(!0)),
          onMouseleave: h[3] || (h[3] = (w) => r(!1)),
          onClick: p,
          class: "px-tag-icon",
          style: oe({
            fill: d.value
          })
        }, null, 8, ["style"])
      ])) : ue("", !0)
    ], 6));
  }
}), El = (t, n, o, e, l, a, r, s, u, f, c) => {
  t.fillStyle = j(r);
  for (let d = 0; d < 4; d++)
    l[d] > s && (!(d === 1 || d === 2) || u && c || !u) && Fe(
      t,
      e[d][0],
      e[d][1],
      l[d],
      a[d][0],
      a[d][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(e[0][0], 0, e[1][0] - e[0][0] + s, s), e[2][1] + s > e[1][1] && (u && c || !u) && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0],
    o - s,
    e[2][0] - e[3][0] + s,
    s
  ), !(u && !f) && e[3][1] + s > e[0][1] && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s), u && !f && t.fillRect(s / 2, 0, s / 2, o), u && !c && t.fillRect(n - 2 * s - 1, 0, s, o);
}, Al = /* @__PURE__ */ X({
  name: "InputGroupLabel",
  __name: "index",
  props: {
    backgroundColor: null,
    borderRadius: null,
    shape: { default: "default" },
    size: { default: "medium" }
  },
  setup(t) {
    var w;
    const n = t, o = et(), e = R(((w = o == null ? void 0 : o.parent) == null ? void 0 : w.type) === wt), [l, a, r] = e.value ? ut(yt) : [R(0), R(!1), R(!1)], s = Ze(bt), u = M(() => e.value && s ? s.borderRadius : n.borderRadius), f = M(() => e.value && s ? s.size : n.size), c = M(() => e.value && s ? s.shape : n.shape), i = R(!1), d = R(!1), p = Le(), m = S(null), v = S(null);
    Re(() => {
      ae(() => {
        h();
      });
    }), we([u, c, i, d, p], () => {
      h();
    }), we([a, r], () => {
      h();
    });
    const h = () => {
      const y = Xe(v, m);
      if (!y)
        return;
      const { ctx: g, width: _, height: x, canvas: k } = y, H = Ne(), L = gt(
        k,
        H,
        u.value,
        c.value,
        f.value || "medium",
        e.value,
        a.value,
        r.value
      ), E = b("neutral", 10), G = ft(L, _, x, H);
      El(
        g,
        _,
        x,
        G,
        L,
        it,
        E,
        H,
        e.value,
        a.value,
        r.value
      );
      const U = n.backgroundColor ? Rt(n.backgroundColor) : b("neutral", 3);
      ct(g, Math.round(_ / 2), Math.round(x / 2), U);
    };
    return We(v, h), qe(h), (y, g) => (C(), B("div", {
      class: se(["pixelium px-input-group-label", {
        "px-input-group-label__large": f.value === "large",
        "px-input-group-label__small": f.value === "small",
        "px-input-group-label__inner": e.value
      }]),
      ref_key: "labelRef",
      ref: v
    }, [
      z("canvas", {
        ref_key: "canvasRef",
        ref: m,
        class: "px-input-group-label-canvas"
      }, null, 512),
      ee(y.$slots, "default")
    ], 2));
  }
}), Dl = (t, n, o, e, l, a, r, s, u, f, c) => {
  t.fillStyle = j(r);
  for (let i = 0; i < 4; i++)
    l[i] <= s || (!(i === 1 || i === 2) || u && c || !u) && Fe(
      t,
      e[i][0],
      e[i][1],
      l[i],
      a[i][0],
      a[i][1],
      s
    );
  if (e[1][0] + s > e[0][0]) {
    const i = u && !c ? e[1][0] - e[0][0] + s / 2 + 1 : e[1][0] - e[0][0] + s;
    t.fillRect(e[0][0], 0, i, s);
  }
  if (e[2][1] + s > e[1][1] && (u && c || !u) && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s) {
    const i = u && !c ? e[2][0] - e[3][0] + s / 2 : e[2][0] - e[3][0] + s;
    t.fillRect(e[3][0], o - s, i, s);
  }
  e[3][1] + s > e[0][1] && !(u && !f) && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s), u && !f && t.fillRect(s / 2, 0, s / 2, o), u && !c && t.fillRect(n - 2 * s - 1, 0, s / 2 + 1, o);
}, Ft = Math.min, Vt = Math.max, nn = Math.round, tt = (t) => ({
  x: t,
  y: t
}), Ol = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Nl = {
  start: "end",
  end: "start"
};
function _n(t, n, o) {
  return Vt(t, Ft(n, o));
}
function qt(t, n) {
  return typeof t == "function" ? t(n) : t;
}
function Mt(t) {
  return t.split("-")[0];
}
function Yt(t) {
  return t.split("-")[1];
}
function go(t) {
  return t === "x" ? "y" : "x";
}
function Vn(t) {
  return t === "y" ? "height" : "width";
}
const Fl = /* @__PURE__ */ new Set(["top", "bottom"]);
function pt(t) {
  return Fl.has(Mt(t)) ? "y" : "x";
}
function $n(t) {
  return go(pt(t));
}
function Gl(t, n, o) {
  o === void 0 && (o = !1);
  const e = Yt(t), l = $n(t), a = Vn(l);
  let r = l === "x" ? e === (o ? "end" : "start") ? "right" : "left" : e === "start" ? "bottom" : "top";
  return n.reference[a] > n.floating[a] && (r = on(r)), [r, on(r)];
}
function Wl(t) {
  const n = on(t);
  return [xn(t), n, xn(n)];
}
function xn(t) {
  return t.replace(/start|end/g, (n) => Nl[n]);
}
const Un = ["left", "right"], jn = ["right", "left"], Ul = ["top", "bottom"], jl = ["bottom", "top"];
function Xl(t, n, o) {
  switch (t) {
    case "top":
    case "bottom":
      return o ? n ? jn : Un : n ? Un : jn;
    case "left":
    case "right":
      return n ? Ul : jl;
    default:
      return [];
  }
}
function ql(t, n, o, e) {
  const l = Yt(t);
  let a = Xl(Mt(t), o === "start", e);
  return l && (a = a.map((r) => r + "-" + l), n && (a = a.concat(a.map(xn)))), a;
}
function on(t) {
  return t.replace(/left|right|bottom|top/g, (n) => Ol[n]);
}
function Yl(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function yo(t) {
  return typeof t != "number" ? Yl(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function an(t) {
  const {
    x: n,
    y: o,
    width: e,
    height: l
  } = t;
  return {
    width: e,
    height: l,
    top: o,
    left: n,
    right: n + e,
    bottom: o + l,
    x: n,
    y: o
  };
}
function Xn(t, n, o) {
  let {
    reference: e,
    floating: l
  } = t;
  const a = pt(n), r = $n(n), s = Vn(r), u = Mt(n), f = a === "y", c = e.x + e.width / 2 - l.width / 2, i = e.y + e.height / 2 - l.height / 2, d = e[s] / 2 - l[s] / 2;
  let p;
  switch (u) {
    case "top":
      p = {
        x: c,
        y: e.y - l.height
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: e.y + e.height
      };
      break;
    case "right":
      p = {
        x: e.x + e.width,
        y: i
      };
      break;
    case "left":
      p = {
        x: e.x - l.width,
        y: i
      };
      break;
    default:
      p = {
        x: e.x,
        y: e.y
      };
  }
  switch (Yt(n)) {
    case "start":
      p[r] -= d * (o && f ? -1 : 1);
      break;
    case "end":
      p[r] += d * (o && f ? -1 : 1);
      break;
  }
  return p;
}
const Kl = async (t, n, o) => {
  const {
    placement: e = "bottom",
    strategy: l = "absolute",
    middleware: a = [],
    platform: r
  } = o, s = a.filter(Boolean), u = await (r.isRTL == null ? void 0 : r.isRTL(n));
  let f = await r.getElementRects({
    reference: t,
    floating: n,
    strategy: l
  }), {
    x: c,
    y: i
  } = Xn(f, e, u), d = e, p = {}, m = 0;
  for (let v = 0; v < s.length; v++) {
    const {
      name: h,
      fn: w
    } = s[v], {
      x: y,
      y: g,
      data: _,
      reset: x
    } = await w({
      x: c,
      y: i,
      initialPlacement: e,
      placement: d,
      strategy: l,
      middlewareData: p,
      rects: f,
      platform: r,
      elements: {
        reference: t,
        floating: n
      }
    });
    c = y ?? c, i = g ?? i, p = {
      ...p,
      [h]: {
        ...p[h],
        ..._
      }
    }, x && m <= 50 && (m++, typeof x == "object" && (x.placement && (d = x.placement), x.rects && (f = x.rects === !0 ? await r.getElementRects({
      reference: t,
      floating: n,
      strategy: l
    }) : x.rects), {
      x: c,
      y: i
    } = Xn(f, d, u)), v = -1);
  }
  return {
    x: c,
    y: i,
    placement: d,
    strategy: l,
    middlewareData: p
  };
};
async function bo(t, n) {
  var o;
  n === void 0 && (n = {});
  const {
    x: e,
    y: l,
    platform: a,
    rects: r,
    elements: s,
    strategy: u
  } = t, {
    boundary: f = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: i = "floating",
    altBoundary: d = !1,
    padding: p = 0
  } = qt(n, t), m = yo(p), h = s[d ? i === "floating" ? "reference" : "floating" : i], w = an(await a.getClippingRect({
    element: (o = await (a.isElement == null ? void 0 : a.isElement(h))) == null || o ? h : h.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: f,
    rootBoundary: c,
    strategy: u
  })), y = i === "floating" ? {
    x: e,
    y: l,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, g = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), _ = await (a.isElement == null ? void 0 : a.isElement(g)) ? await (a.getScale == null ? void 0 : a.getScale(g)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = an(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: y,
    offsetParent: g,
    strategy: u
  }) : y);
  return {
    top: (w.top - x.top + m.top) / _.y,
    bottom: (x.bottom - w.bottom + m.bottom) / _.y,
    left: (w.left - x.left + m.left) / _.x,
    right: (x.right - w.right + m.right) / _.x
  };
}
const Ql = (t) => ({
  name: "arrow",
  options: t,
  async fn(n) {
    const {
      x: o,
      y: e,
      placement: l,
      rects: a,
      platform: r,
      elements: s,
      middlewareData: u
    } = n, {
      element: f,
      padding: c = 0
    } = qt(t, n) || {};
    if (f == null)
      return {};
    const i = yo(c), d = {
      x: o,
      y: e
    }, p = $n(l), m = Vn(p), v = await r.getDimensions(f), h = p === "y", w = h ? "top" : "left", y = h ? "bottom" : "right", g = h ? "clientHeight" : "clientWidth", _ = a.reference[m] + a.reference[p] - d[p] - a.floating[m], x = d[p] - a.reference[p], k = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(f));
    let H = k ? k[g] : 0;
    (!H || !await (r.isElement == null ? void 0 : r.isElement(k))) && (H = s.floating[g] || a.floating[m]);
    const L = _ / 2 - x / 2, E = H / 2 - v[m] / 2 - 1, G = Ft(i[w], E), D = Ft(i[y], E), U = G, A = H - v[m] - D, F = H / 2 - v[m] / 2 + L, K = _n(U, F, A), ne = !u.arrow && Yt(l) != null && F !== K && a.reference[m] / 2 - (F < U ? G : D) - v[m] / 2 < 0, O = ne ? F < U ? F - U : F - A : 0;
    return {
      [p]: d[p] + O,
      data: {
        [p]: K,
        centerOffset: F - K - O,
        ...ne && {
          alignmentOffset: O
        }
      },
      reset: ne
    };
  }
}), Jl = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(n) {
      var o, e;
      const {
        placement: l,
        middlewareData: a,
        rects: r,
        initialPlacement: s,
        platform: u,
        elements: f
      } = n, {
        mainAxis: c = !0,
        crossAxis: i = !0,
        fallbackPlacements: d,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: v = !0,
        ...h
      } = qt(t, n);
      if ((o = a.arrow) != null && o.alignmentOffset)
        return {};
      const w = Mt(l), y = pt(s), g = Mt(s) === s, _ = await (u.isRTL == null ? void 0 : u.isRTL(f.floating)), x = d || (g || !v ? [on(s)] : Wl(s)), k = m !== "none";
      !d && k && x.push(...ql(s, v, m, _));
      const H = [s, ...x], L = await bo(n, h), E = [];
      let G = ((e = a.flip) == null ? void 0 : e.overflows) || [];
      if (c && E.push(L[w]), i) {
        const F = Gl(l, r, _);
        E.push(L[F[0]], L[F[1]]);
      }
      if (G = [...G, {
        placement: l,
        overflows: E
      }], !E.every((F) => F <= 0)) {
        var D, U;
        const F = (((D = a.flip) == null ? void 0 : D.index) || 0) + 1, K = H[F];
        if (K && (!(i === "alignment" ? y !== pt(K) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        G.every((Q) => pt(Q.placement) === y ? Q.overflows[0] > 0 : !0)))
          return {
            data: {
              index: F,
              overflows: G
            },
            reset: {
              placement: K
            }
          };
        let ne = (U = G.filter((O) => O.overflows[0] <= 0).sort((O, Q) => O.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : U.placement;
        if (!ne)
          switch (p) {
            case "bestFit": {
              var A;
              const O = (A = G.filter((Q) => {
                if (k) {
                  const W = pt(Q.placement);
                  return W === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  W === "y";
                }
                return !0;
              }).map((Q) => [Q.placement, Q.overflows.filter((W) => W > 0).reduce((W, _e) => W + _e, 0)]).sort((Q, W) => Q[1] - W[1])[0]) == null ? void 0 : A[0];
              O && (ne = O);
              break;
            }
            case "initialPlacement":
              ne = s;
              break;
          }
        if (l !== ne)
          return {
            reset: {
              placement: ne
            }
          };
      }
      return {};
    }
  };
}, Zl = /* @__PURE__ */ new Set(["left", "top"]);
async function Sl(t, n) {
  const {
    placement: o,
    platform: e,
    elements: l
  } = t, a = await (e.isRTL == null ? void 0 : e.isRTL(l.floating)), r = Mt(o), s = Yt(o), u = pt(o) === "y", f = Zl.has(r) ? -1 : 1, c = a && u ? -1 : 1, i = qt(n, t);
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: m
  } = typeof i == "number" ? {
    mainAxis: i,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: i.mainAxis || 0,
    crossAxis: i.crossAxis || 0,
    alignmentAxis: i.alignmentAxis
  };
  return s && typeof m == "number" && (p = s === "end" ? m * -1 : m), u ? {
    x: p * c,
    y: d * f
  } : {
    x: d * f,
    y: p * c
  };
}
const zl = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(n) {
      var o, e;
      const {
        x: l,
        y: a,
        placement: r,
        middlewareData: s
      } = n, u = await Sl(n, t);
      return r === ((o = s.offset) == null ? void 0 : o.placement) && (e = s.arrow) != null && e.alignmentOffset ? {} : {
        x: l + u.x,
        y: a + u.y,
        data: {
          ...u,
          placement: r
        }
      };
    }
  };
}, es = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(n) {
      const {
        x: o,
        y: e,
        placement: l
      } = n, {
        mainAxis: a = !0,
        crossAxis: r = !1,
        limiter: s = {
          fn: (h) => {
            let {
              x: w,
              y
            } = h;
            return {
              x: w,
              y
            };
          }
        },
        ...u
      } = qt(t, n), f = {
        x: o,
        y: e
      }, c = await bo(n, u), i = pt(Mt(l)), d = go(i);
      let p = f[d], m = f[i];
      if (a) {
        const h = d === "y" ? "top" : "left", w = d === "y" ? "bottom" : "right", y = p + c[h], g = p - c[w];
        p = _n(y, p, g);
      }
      if (r) {
        const h = i === "y" ? "top" : "left", w = i === "y" ? "bottom" : "right", y = m + c[h], g = m - c[w];
        m = _n(y, m, g);
      }
      const v = s.fn({
        ...n,
        [d]: p,
        [i]: m
      });
      return {
        ...v,
        data: {
          x: v.x - o,
          y: v.y - e,
          enabled: {
            [d]: a,
            [i]: r
          }
        }
      };
    }
  };
};
function sn() {
  return typeof window < "u";
}
function Lt(t) {
  return wo(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Ge(t) {
  var n;
  return (t == null || (n = t.ownerDocument) == null ? void 0 : n.defaultView) || window;
}
function dt(t) {
  var n;
  return (n = (wo(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : n.documentElement;
}
function wo(t) {
  return sn() ? t instanceof Node || t instanceof Ge(t).Node : !1;
}
function Se(t) {
  return sn() ? t instanceof Element || t instanceof Ge(t).Element : !1;
}
function nt(t) {
  return sn() ? t instanceof HTMLElement || t instanceof Ge(t).HTMLElement : !1;
}
function qn(t) {
  return !sn() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Ge(t).ShadowRoot;
}
const ts = /* @__PURE__ */ new Set(["inline", "contents"]);
function Kt(t) {
  const {
    overflow: n,
    overflowX: o,
    overflowY: e,
    display: l
  } = ze(t);
  return /auto|scroll|overlay|hidden|clip/.test(n + e + o) && !ts.has(l);
}
const ns = /* @__PURE__ */ new Set(["table", "td", "th"]);
function os(t) {
  return ns.has(Lt(t));
}
const as = [":popover-open", ":modal"];
function rn(t) {
  return as.some((n) => {
    try {
      return t.matches(n);
    } catch {
      return !1;
    }
  });
}
const ls = ["transform", "translate", "scale", "rotate", "perspective"], ss = ["transform", "translate", "scale", "rotate", "perspective", "filter"], rs = ["paint", "layout", "strict", "content"];
function Tn(t) {
  const n = Bn(), o = Se(t) ? ze(t) : t;
  return ls.some((e) => o[e] ? o[e] !== "none" : !1) || (o.containerType ? o.containerType !== "normal" : !1) || !n && (o.backdropFilter ? o.backdropFilter !== "none" : !1) || !n && (o.filter ? o.filter !== "none" : !1) || ss.some((e) => (o.willChange || "").includes(e)) || rs.some((e) => (o.contain || "").includes(e));
}
function us(t) {
  let n = ht(t);
  for (; nt(n) && !Pt(n); ) {
    if (Tn(n))
      return n;
    if (rn(n))
      return null;
    n = ht(n);
  }
  return null;
}
function Bn() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const is = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Pt(t) {
  return is.has(Lt(t));
}
function ze(t) {
  return Ge(t).getComputedStyle(t);
}
function un(t) {
  return Se(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function ht(t) {
  if (Lt(t) === "html")
    return t;
  const n = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    qn(t) && t.host || // Fallback.
    dt(t)
  );
  return qn(n) ? n.host : n;
}
function _o(t) {
  const n = ht(t);
  return Pt(n) ? t.ownerDocument ? t.ownerDocument.body : t.body : nt(n) && Kt(n) ? n : _o(n);
}
function xo(t, n, o) {
  var e;
  n === void 0 && (n = []);
  const l = _o(t), a = l === ((e = t.ownerDocument) == null ? void 0 : e.body), r = Ge(l);
  return a ? (Cn(r), n.concat(r, r.visualViewport || [], Kt(l) ? l : [], [])) : n.concat(l, xo(l, []));
}
function Cn(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function Co(t) {
  const n = ze(t);
  let o = parseFloat(n.width) || 0, e = parseFloat(n.height) || 0;
  const l = nt(t), a = l ? t.offsetWidth : o, r = l ? t.offsetHeight : e, s = nn(o) !== a || nn(e) !== r;
  return s && (o = a, e = r), {
    width: o,
    height: e,
    $: s
  };
}
function Mo(t) {
  return Se(t) ? t : t.contextElement;
}
function $t(t) {
  const n = Mo(t);
  if (!nt(n))
    return tt(1);
  const o = n.getBoundingClientRect(), {
    width: e,
    height: l,
    $: a
  } = Co(n);
  let r = (a ? nn(o.width) : o.width) / e, s = (a ? nn(o.height) : o.height) / l;
  return (!r || !Number.isFinite(r)) && (r = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: r,
    y: s
  };
}
const cs = /* @__PURE__ */ tt(0);
function Ro(t) {
  const n = Ge(t);
  return !Bn() || !n.visualViewport ? cs : {
    x: n.visualViewport.offsetLeft,
    y: n.visualViewport.offsetTop
  };
}
function fs(t, n, o) {
  return n === void 0 && (n = !1), !o || n && o !== Ge(t) ? !1 : n;
}
function Gt(t, n, o, e) {
  n === void 0 && (n = !1), o === void 0 && (o = !1);
  const l = t.getBoundingClientRect(), a = Mo(t);
  let r = tt(1);
  n && (e ? Se(e) && (r = $t(e)) : r = $t(t));
  const s = fs(a, o, e) ? Ro(a) : tt(0);
  let u = (l.left + s.x) / r.x, f = (l.top + s.y) / r.y, c = l.width / r.x, i = l.height / r.y;
  if (a) {
    const d = Ge(a), p = e && Se(e) ? Ge(e) : e;
    let m = d, v = Cn(m);
    for (; v && e && p !== m; ) {
      const h = $t(v), w = v.getBoundingClientRect(), y = ze(v), g = w.left + (v.clientLeft + parseFloat(y.paddingLeft)) * h.x, _ = w.top + (v.clientTop + parseFloat(y.paddingTop)) * h.y;
      u *= h.x, f *= h.y, c *= h.x, i *= h.y, u += g, f += _, m = Ge(v), v = Cn(m);
    }
  }
  return an({
    width: c,
    height: i,
    x: u,
    y: f
  });
}
function cn(t, n) {
  const o = un(t).scrollLeft;
  return n ? n.left + o : Gt(dt(t)).left + o;
}
function Ho(t, n) {
  const o = t.getBoundingClientRect(), e = o.left + n.scrollLeft - cn(t, o), l = o.top + n.scrollTop;
  return {
    x: e,
    y: l
  };
}
function ds(t) {
  let {
    elements: n,
    rect: o,
    offsetParent: e,
    strategy: l
  } = t;
  const a = l === "fixed", r = dt(e), s = n ? rn(n.floating) : !1;
  if (e === r || s && a)
    return o;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = tt(1);
  const c = tt(0), i = nt(e);
  if ((i || !i && !a) && ((Lt(e) !== "body" || Kt(r)) && (u = un(e)), nt(e))) {
    const p = Gt(e);
    f = $t(e), c.x = p.x + e.clientLeft, c.y = p.y + e.clientTop;
  }
  const d = r && !i && !a ? Ho(r, u) : tt(0);
  return {
    width: o.width * f.x,
    height: o.height * f.y,
    x: o.x * f.x - u.scrollLeft * f.x + c.x + d.x,
    y: o.y * f.y - u.scrollTop * f.y + c.y + d.y
  };
}
function ps(t) {
  return Array.from(t.getClientRects());
}
function vs(t) {
  const n = dt(t), o = un(t), e = t.ownerDocument.body, l = Vt(n.scrollWidth, n.clientWidth, e.scrollWidth, e.clientWidth), a = Vt(n.scrollHeight, n.clientHeight, e.scrollHeight, e.clientHeight);
  let r = -o.scrollLeft + cn(t);
  const s = -o.scrollTop;
  return ze(e).direction === "rtl" && (r += Vt(n.clientWidth, e.clientWidth) - l), {
    width: l,
    height: a,
    x: r,
    y: s
  };
}
const Yn = 25;
function ms(t, n) {
  const o = Ge(t), e = dt(t), l = o.visualViewport;
  let a = e.clientWidth, r = e.clientHeight, s = 0, u = 0;
  if (l) {
    a = l.width, r = l.height;
    const c = Bn();
    (!c || c && n === "fixed") && (s = l.offsetLeft, u = l.offsetTop);
  }
  const f = cn(e);
  if (f <= 0) {
    const c = e.ownerDocument, i = c.body, d = getComputedStyle(i), p = c.compatMode === "CSS1Compat" && parseFloat(d.marginLeft) + parseFloat(d.marginRight) || 0, m = Math.abs(e.clientWidth - i.clientWidth - p);
    m <= Yn && (a -= m);
  } else f <= Yn && (a += f);
  return {
    width: a,
    height: r,
    x: s,
    y: u
  };
}
const hs = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function gs(t, n) {
  const o = Gt(t, !0, n === "fixed"), e = o.top + t.clientTop, l = o.left + t.clientLeft, a = nt(t) ? $t(t) : tt(1), r = t.clientWidth * a.x, s = t.clientHeight * a.y, u = l * a.x, f = e * a.y;
  return {
    width: r,
    height: s,
    x: u,
    y: f
  };
}
function Kn(t, n, o) {
  let e;
  if (n === "viewport")
    e = ms(t, o);
  else if (n === "document")
    e = vs(dt(t));
  else if (Se(n))
    e = gs(n, o);
  else {
    const l = Ro(t);
    e = {
      x: n.x - l.x,
      y: n.y - l.y,
      width: n.width,
      height: n.height
    };
  }
  return an(e);
}
function ko(t, n) {
  const o = ht(t);
  return o === n || !Se(o) || Pt(o) ? !1 : ze(o).position === "fixed" || ko(o, n);
}
function ys(t, n) {
  const o = n.get(t);
  if (o)
    return o;
  let e = xo(t, []).filter((s) => Se(s) && Lt(s) !== "body"), l = null;
  const a = ze(t).position === "fixed";
  let r = a ? ht(t) : t;
  for (; Se(r) && !Pt(r); ) {
    const s = ze(r), u = Tn(r);
    !u && s.position === "fixed" && (l = null), (a ? !u && !l : !u && s.position === "static" && !!l && hs.has(l.position) || Kt(r) && !u && ko(t, r)) ? e = e.filter((c) => c !== r) : l = s, r = ht(r);
  }
  return n.set(t, e), e;
}
function bs(t) {
  let {
    element: n,
    boundary: o,
    rootBoundary: e,
    strategy: l
  } = t;
  const r = [...o === "clippingAncestors" ? rn(n) ? [] : ys(n, this._c) : [].concat(o), e], s = r[0], u = r.reduce((f, c) => {
    const i = Kn(n, c, l);
    return f.top = Vt(i.top, f.top), f.right = Ft(i.right, f.right), f.bottom = Ft(i.bottom, f.bottom), f.left = Vt(i.left, f.left), f;
  }, Kn(n, s, l));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function ws(t) {
  const {
    width: n,
    height: o
  } = Co(t);
  return {
    width: n,
    height: o
  };
}
function _s(t, n, o) {
  const e = nt(n), l = dt(n), a = o === "fixed", r = Gt(t, !0, a, n);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = tt(0);
  function f() {
    u.x = cn(l);
  }
  if (e || !e && !a)
    if ((Lt(n) !== "body" || Kt(l)) && (s = un(n)), e) {
      const p = Gt(n, !0, a, n);
      u.x = p.x + n.clientLeft, u.y = p.y + n.clientTop;
    } else l && f();
  a && !e && l && f();
  const c = l && !e && !a ? Ho(l, s) : tt(0), i = r.left + s.scrollLeft - u.x - c.x, d = r.top + s.scrollTop - u.y - c.y;
  return {
    x: i,
    y: d,
    width: r.width,
    height: r.height
  };
}
function gn(t) {
  return ze(t).position === "static";
}
function Qn(t, n) {
  if (!nt(t) || ze(t).position === "fixed")
    return null;
  if (n)
    return n(t);
  let o = t.offsetParent;
  return dt(t) === o && (o = o.ownerDocument.body), o;
}
function Vo(t, n) {
  const o = Ge(t);
  if (rn(t))
    return o;
  if (!nt(t)) {
    let l = ht(t);
    for (; l && !Pt(l); ) {
      if (Se(l) && !gn(l))
        return l;
      l = ht(l);
    }
    return o;
  }
  let e = Qn(t, n);
  for (; e && os(e) && gn(e); )
    e = Qn(e, n);
  return e && Pt(e) && gn(e) && !Tn(e) ? o : e || us(t) || o;
}
const xs = async function(t) {
  const n = this.getOffsetParent || Vo, o = this.getDimensions, e = await o(t.floating);
  return {
    reference: _s(t.reference, await n(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: e.width,
      height: e.height
    }
  };
};
function Cs(t) {
  return ze(t).direction === "rtl";
}
const Ms = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ds,
  getDocumentElement: dt,
  getClippingRect: bs,
  getOffsetParent: Vo,
  getElementRects: xs,
  getClientRects: ps,
  getDimensions: ws,
  getScale: $t,
  isElement: Se,
  isRTL: Cs
}, Rs = zl, Hs = es, ks = Jl, Vs = Ql, $s = (t, n, o) => {
  const e = /* @__PURE__ */ new Map(), l = {
    platform: Ms,
    ...o
  }, a = {
    ...l.platform,
    _c: e
  };
  return Kl(t, n, {
    ...l,
    platform: a
  });
};
function Ts(t) {
  return t === "light" ? b("neutral", 10) : b("neutral", 9);
}
function Bs(t) {
  return t === "light" ? b("neutral", 1) : b("neutral", 10);
}
const Ps = (t, n, o, e, l, a, r, s, u, f, c, i) => {
  t.fillStyle = j(r);
  for (let d = 0; d < 4; d++)
    l[d] > s && Fe(
      t,
      e[d][0] + i,
      e[d][1] + c,
      l[d],
      a[d][0],
      a[d][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(
    e[0][0] + i,
    c,
    e[1][0] - e[0][0] + s,
    s
  ), e[2][1] + s > e[1][1] && t.fillRect(
    n - u - s + i,
    e[1][1] + c,
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0] + i,
    o - f - s + c,
    e[2][0] - e[3][0] + s,
    s
  ), e[3][1] + s > e[0][1] && t.fillRect(
    i,
    e[0][1] + c,
    s,
    e[3][1] - e[0][1] + s
  );
}, Is = (t, n, o, e, l, a, r, s, u, f) => {
  switch (r) {
    case "right": {
      const c = f - a / 2, i = [
        0,
        s === "start" ? Math.floor(c) : s === "end" ? Math.ceil(c) : Math.round(c)
      ];
      for (let d = 0; d < 4; d++) {
        const p = d > 1 ? d - 1 : d;
        t.fillStyle = j(e);
        const m = Math.max(0, i[1] - p * a), v = Math.min(o, i[1] + p * a), h = i[0] + d * a;
        t.fillRect(h, m, a, a), t.fillRect(h, v, a, a), t.fillStyle = j(l), v - m - a > 0 && t.fillRect(h, m + a, a, v - m - a);
      }
      break;
    }
    case "left": {
      const c = f - a / 2, i = [
        Math.round(n - a),
        s === "start" ? Math.floor(c) : s === "end" ? Math.ceil(c) : Math.round(c)
      ];
      for (let d = 0; d < 4; d++) {
        const p = d > 1 ? d - 1 : d;
        t.fillStyle = j(e);
        const m = Math.max(0, i[1] - p * a), v = Math.min(o - a, i[1] + p * a), h = i[0] - d * a;
        t.fillRect(h, m, a, a), t.fillRect(h, v, a, a), t.fillStyle = j(l), v - m - a > 0 && t.fillRect(h, m + a, a, v - m - a);
      }
      break;
    }
    case "bottom": {
      const c = u - a / 2, i = [
        s === "start" ? Math.floor(c) : s === "end" ? Math.ceil(c) : Math.round(c),
        0
      ];
      for (let d = 0; d < 4; d++) {
        const p = d > 1 ? d - 1 : d;
        t.fillStyle = j(e);
        const m = Math.max(0, i[0] - p * a), v = Math.min(i[0] + p * a, n - a), h = i[1] + d * a;
        t.fillRect(m, h, a, a), t.fillRect(v, h, a, a), t.fillStyle = j(l), v - m - a > 0 && t.fillRect(m + a, h, v - m - a, a);
      }
      break;
    }
    case "top":
    default: {
      const c = u - a / 2, i = [
        s === "start" ? Math.floor(c) : s === "end" ? Math.ceil(c) : Math.round(c),
        Math.round(o - a)
      ];
      for (let d = 0; d < 4; d++) {
        const p = d > 1 ? d - 1 : d;
        t.fillStyle = j(e);
        const m = Math.max(0, i[0] - p * a), v = Math.min(i[0] + p * a, n - a), h = i[1] - d * a;
        t.fillRect(m, h, a, a), t.fillRect(v, h, a, a), t.fillStyle = j(l), v - m - a > 0 && t.fillRect(m + a, h, v - m - a, a);
      }
      break;
    }
  }
}, Ls = 250, $o = /* @__PURE__ */ X({
  name: "PopupContent",
  __name: "index",
  props: {
    content: null,
    visible: { type: Boolean, default: void 0 },
    defaultVisible: { type: Boolean },
    placement: { default: "top" },
    offset: { default: 8 },
    variant: { default: "light" },
    arrow: { type: Boolean, default: !0 },
    zIndex: null,
    target: null,
    root: { default: "body" },
    borderRadius: null,
    widthEqual: { type: Boolean, default: !1 },
    contentStyle: null
  },
  emits: ["contentMouseenter", "contentMouseleave"],
  setup(t, { expose: n, emit: o }) {
    const e = t, [l, a] = fo("popup"), r = R(!1), s = S(null), u = S(null), f = S(null), c = R({}), i = R({}), d = R(void 0), p = R(void 0), m = R(void 0), v = M(() => e.placement.split("-")[0]), h = M(() => e.placement.split("-")[1] || "middle"), w = R(void 0);
    async function y(D) {
      if (!ie() || !s.value || !u.value || !f.value) return;
      const U = getComputedStyle(s.value), A = parseFloat(U.borderLeftWidth) + parseFloat(U.borderRightWidth), F = A / 2, K = (parseFloat(U.borderTopWidth) + parseFloat(U.borderBottomWidth)) / 2;
      if ((v.value === "top" || v.value === "bottom") && e.widthEqual) {
        const J = getComputedStyle(D), ye = J.boxSizing, me = U.boxSizing, $e = parseFloat(J.paddingLeft) + parseFloat(J.paddingRight), q = parseFloat(U.paddingLeft) + parseFloat(U.paddingRight), T = parseFloat(J.borderLeftWidth) + parseFloat(J.borderRightWidth), Y = parseFloat(J.width);
        ye === "border-box" ? me === "border-box" ? w.value = Y : w.value = Y - q - A : me === "border-box" ? w.value = Y + $e + T : w.value = Y - q - A + $e + T, await ae();
      } else
        w.value = void 0;
      const ne = Ne(), O = Math.max(e.borderRadius || ne, ne), Q = Math.max(
        0,
        O - Et(ne, O) + ne
      ), W = await $s(D, s.value, {
        placement: e.placement,
        middleware: [
          Rs(e.offset),
          Hs(),
          ks(),
          Vs({ element: u.value, padding: Q })
        ]
      }), { x: _e, y: pe, middlewareData: be, placement: ce } = W;
      c.value = {
        left: `${_e}px`,
        top: `${pe}px`
      };
      const { x: ve, y: re } = be.arrow ?? {};
      m.value = ce.split("-")[0], i.value = {
        left: ve ? `${ve + F}px` : void 0,
        top: re ? `${re + K}px` : void 0
      }, d.value = ve ? ve + F : void 0, p.value = re ? re + K : void 0, ae(() => {
        e.visible && (r.value = !0);
      });
    }
    async function g(D) {
      setTimeout(() => {
        y(D);
      });
    }
    async function _() {
      setTimeout(() => {
        r.value = !1, m.value = void 0;
      }, Ls);
    }
    const x = (D) => {
      ie() && (D ? (a(), e.target instanceof HTMLElement ? g(e.target) : e.target && e.target.el instanceof HTMLElement && g(e.target.el)) : _());
    };
    we(
      () => e.visible,
      (D) => {
        x(!!D);
      }
    );
    const k = o, H = (D) => {
      k("contentMouseenter", D);
    }, L = (D) => {
      k("contentMouseleave", D);
    };
    n({
      updateRenderState: () => {
        ae(() => {
          x(!!e.visible);
        });
      },
      content: s
    });
    const E = Le();
    Re(() => {
      ae(() => {
        G(), x(!!e.visible);
      });
    }), we(
      [
        E,
        m,
        d,
        p,
        r,
        () => e.variant,
        () => e.arrow
      ],
      () => {
        G();
      }
    );
    const G = () => {
      if (!m.value)
        return;
      const D = Xe(s, f);
      if (!D)
        return;
      const { ctx: U, width: A, height: F } = D, K = Ne(), ne = Ie(Math.max(e.borderRadius || K, K), 4), O = e.arrow ? K * 3 : 0, Q = m.value === "left" || m.value === "right" ? O : 0, W = m.value === "top" || m.value === "bottom" ? O : 0, _e = Ts(e.variant), pe = ft(
        ne,
        A,
        F,
        K,
        Q,
        W
      ), be = it, ce = m.value === "bottom" ? O : 0, ve = m.value === "right" ? O : 0;
      Ps(
        U,
        A,
        F,
        pe,
        ne,
        be,
        _e,
        K,
        Q,
        W,
        ce,
        ve
      );
      const re = Bs(e.variant);
      ct(
        U,
        Math.round((A - Q) / 2 + ve),
        Math.round((F - W) / 2 + ce),
        re
      ), e.arrow && Is(
        U,
        A,
        F,
        _e,
        re,
        K,
        m.value,
        h.value,
        d.value || 0,
        p.value || 0
      );
    };
    return We(s, G), qe(G), (D, U) => (C(), Ve(to, {
      to: e.root || "body"
    }, [
      I(eo, {
        name: "px-popup-content-fade__" + v.value
      }, {
        default: _t(() => [
          Zt(z("div", Rn({
            ref_key: "contentRef",
            ref: s,
            class: {
              pixelium: !0,
              "px-popup-content": !0,
              "px-popup-content__arrow": !!e.arrow,
              [`px-popup-content__${m.value || v.value}`]: !0,
              [`px-popup-content__${e.variant}`]: !0
            },
            style: {
              ...c.value,
              visibility: r.value ? "visible" : "hidden",
              pointerEvents: r.value ? "auto" : "none",
              zIndex: e.zIndex ?? V(l),
              width: V(he)(w.value) ? `${w.value}px` : void 0,
              ...e.contentStyle
            }
          }, D.$attrs, {
            onMouseenter: H,
            onMouseleave: L
          }), [
            ee(D.$slots, "content", {}, () => [
              Je(Ae(e.content), 1)
            ]),
            z("div", {
              class: "px-popup-content-arrow",
              style: oe(i.value),
              ref_key: "arrowRef",
              ref: u
            }, null, 4),
            z("canvas", {
              class: "px-popup-content-canvas",
              ref_key: "canvasRef",
              ref: f
            }, null, 512)
          ], 16), [
            [St, e.visible]
          ])
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["to"]));
  }
}), Jn = (t, n) => n ? n.contains(t) : !0, Zn = (t) => {
  if (Xt(t)) {
    const n = t();
    return n instanceof HTMLElement ? n : null;
  }
  return t.value ? t.value instanceof HTMLElement ? t.value : t.value.el && t.value.el instanceof HTMLElement ? t.value.el : null : null;
}, To = (t, n) => {
  const o = (e) => {
    const l = e.target;
    if (!(l instanceof HTMLElement) || (rt(t) ? t.length === 0 : !Xt(t) && !t.value))
      return;
    (rt(t) ? t.reduce((r, s) => r || Jn(l, Zn(s)), !1) : Jn(l, Zn(t))) || n(e);
  };
  Re(() => {
    document.addEventListener("click", o);
  }), Ue(() => {
    document.removeEventListener("click", o);
  });
}, Bo = /* @__PURE__ */ X({
  name: "PopupTrigger",
  __name: "index",
  props: {
    trigger: {
      default: "hover"
    },
    disabled: {
      type: Boolean
    }
  },
  emits: ["close", "open"],
  setup(t, {
    expose: n,
    emit: o
  }) {
    const e = t, l = o, a = S(null);
    async function r(i, d) {
      ie() && (i.el instanceof HTMLElement ? a.value = i : a.value = null), !e.disabled && l("open", i, d);
    }
    async function s(i) {
      e.disabled || l("close", i);
    }
    const u = je();
    To(a, (i) => {
      e.trigger === "click" && s(i);
    });
    const c = S(null);
    return n({
      firstVNode: c
    }), () => {
      var d;
      const i = Ot(((d = u.default) == null ? void 0 : d.call(u)) || []);
      return I(De, null, [i.map((p, m) => {
        if (Da(p)) {
          const v = e.trigger === "click" ? I("span", {
            onClick: (h) => r(v, h)
          }, [p]) : I("span", {
            onMouseenter: (h) => r(v, h),
            onMouseleave: (h) => s(h)
          }, [p]);
          return m === 0 && (c.value = v, a.value || (a.value = v)), v;
        } else {
          const v = Uo(p, Rn(p.props || {}, e.trigger === "click" ? {
            onClick: (h) => r(v, h)
          } : {
            onMouseenter: (h) => r(v, h),
            onMouseleave: (h) => s(h)
          }));
          return v.ref = p.ref, m === 0 && (c.value = v, a.value || (a.value = v)), v;
        }
      })]);
    };
  }
}), Es = 16, As = 300, Wt = /* @__PURE__ */ X({
  name: "Popover",
  __name: "index",
  props: {
    content: null,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    placement: {
      default: "top"
    },
    trigger: {
      default: "hover"
    },
    offset: {
      default: 8
    },
    variant: {
      default: "light"
    },
    arrow: {
      type: Boolean,
      default: !0
    },
    disabled: {
      type: Boolean
    },
    zIndex: null,
    root: {
      default: "body"
    },
    widthEqual: {
      type: Boolean,
      default: !1
    },
    contentStyle: null
  },
  emits: ["update:visible", "close", "open"],
  setup(t, {
    expose: n,
    emit: o
  }) {
    const e = t, l = M(() => e.visible !== void 0), a = l.value ? e.visible : e.defaultVisible, r = R(Me(a) ? !1 : a), s = S(), u = S(), f = o, c = S(null);
    let i;
    async function d(H, L) {
      i && (i(), i = void 0), await p(H), f("open", L);
    }
    async function p(H, L = !1) {
      ie() && (g == null || g.disconnect(), H.el instanceof HTMLElement ? c.value = H : c.value = null, c.value && c.value.el instanceof HTMLElement && (g == null || g.observe(c.value.el))), l.value && !L ? (f("update:visible", !0), await ae(() => {
      }), r.value = !!e.visible) : r.value = !0;
    }
    async function m(H) {
      if (e.trigger === "click") {
        if (s.value && s.value.content && s.value.content.contains(H.target) || !r.value)
          return;
      } else {
        i && (i(), i = void 0);
        const {
          resolve: L,
          reject: E,
          promise: G
        } = Promise.withResolvers();
        i = E, setTimeout(() => {
          L();
        }, As);
        try {
          await G;
        } catch {
          return;
        }
      }
      l.value ? (f("update:visible", !1), await ae(() => {
      }), r.value = !!e.visible) : r.value = !1, f("close", H);
    }
    const v = () => {
      e.trigger !== "click" && i && (i(), i = void 0);
    }, h = (H) => {
      e.trigger !== "click" && m(H);
    }, w = () => {
      ie() && !c.value && u.value && u.value.firstVNode && (g == null || g.disconnect(), c.value = u.value.firstVNode, c.value.el instanceof HTMLElement && (g == null || g.observe(c.value.el)));
    }, y = (H) => {
      H ? (w(), c.value && p(c.value, !0)) : r.value = !1;
    };
    we(() => e.visible, () => {
      y(!!e.visible);
    });
    const g = ie() ? new ResizeObserver(() => {
      _();
    }) : null;
    Re(() => {
      ae(() => {
        r.value && _();
      });
    });
    const _ = () => {
      var H;
      w(), ie() && ((H = s.value) == null || H.updateRenderState());
    };
    n({
      triggerContent: s,
      updateRenderState: _
    });
    const x = je(), k = (H) => {
      var L;
      return ie() ? ((L = c.value) == null ? void 0 : L.el) instanceof HTMLElement : !1;
    };
    return () => {
      var H;
      return I(De, null, [I(Bo, {
        trigger: e.trigger,
        disabled: e.disabled,
        onClose: m,
        onOpen: d,
        ref: (L) => u.value = L
      }, {
        default: () => {
          var L;
          return [(L = x.default) == null ? void 0 : L.call(x)];
        }
      }), I($o, {
        visible: r.value,
        content: e.content,
        zIndex: e.zIndex,
        variant: e.variant,
        placement: e.placement,
        arrow: e.arrow,
        offset: e.offset,
        borderRadius: Es,
        root: e.root,
        widthEqual: e.widthEqual,
        target: k((H = c.value) == null ? void 0 : H.el) ? c.value.el : null,
        onContentMouseenter: v,
        onContentMouseleave: h,
        contentStyle: e.contentStyle,
        ref: (L) => s.value = L
      }, {
        content: x.content
      })]);
    };
  }
}), Ds = {
  key: 0,
  class: "px-input-tag-prefix-wrapper"
}, Os = { class: "px-input-tag-content" }, Ns = { class: "px-input-tag-content" }, Fs = ["value", "placeholder", "disabled", "autofocus"], Gs = {
  key: 1,
  class: "px-input-tag-close-wrapper"
}, Ws = {
  key: 1,
  class: "px-input-tag-icon-placeholder"
}, Us = {
  key: 2,
  class: "px-input-tag-loading-wrapper"
}, js = {
  key: 3,
  class: "px-input-tag-suffix-wrapper"
}, Xs = /* @__PURE__ */ X({
  name: "InputTag",
  __name: "index",
  props: {
    modelValue: null,
    defaultValue: null,
    inputValue: null,
    defaultInputValue: null,
    placeholder: null,
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    clearable: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    size: { default: "medium" },
    shape: { default: "default" },
    borderRadius: null,
    maxLength: null,
    collapseTags: { type: Boolean, default: !1 },
    maxDisplayTags: null,
    collapseTagsPopover: { type: Boolean, default: !0 },
    tagTheme: { default: "info" },
    tagVariant: { default: "plain" },
    tagColor: null,
    status: { default: "normal" },
    autofocus: { type: Boolean }
  },
  emits: ["update:modelValue", "tagAdd", "tagClose", "change", "input", "update:inputValue", "inputChange", "clear", "blur", "focus"],
  setup(t, { expose: n, emit: o }) {
    var q;
    const e = t, l = o, [a, r, s] = It({
      afterComposition: (T) => {
        ae(() => {
          G(T);
        });
      }
    }), u = et(), f = R(((q = u == null ? void 0 : u.parent) == null ? void 0 : q.type) === wt), [c, i, d] = f.value ? ut(yt) : [R(0), R(!1), R(!1)], p = Ze(bt), m = M(() => f.value && p ? p.borderRadius : e.borderRadius), v = M(() => f.value && p ? p.size : e.size), h = M(() => f.value && p ? p.shape : e.shape), w = M(() => f.value && p && p.disabled || e.disabled), y = M(() => v.value === "small" ? "small" : "medium"), [g, _] = mt("modelValue", e, l, {
      defaultField: "defaultValue",
      transform: (T) => rt(T) ? [...T] : []
    }), [x, k] = mt("inputValue", e, l, {
      defaultField: "defaultInputValue",
      transform: (T) => T || ""
    }), H = S(null), L = S(null), E = S(null), G = async (T) => {
      const te = T.target.value;
      x.value = te, !a.value && (l("input", te, T), k(te));
    }, D = async () => {
      const T = [];
      await _(T), await k(""), l("clear", T), l("change", T), l("inputChange", "");
    }, U = async (T, Y) => {
      const te = g.value ? [...g.value] : [], fe = te.splice(T, 1);
      await _(te), l("tagClose", fe[0], T, Y), l("change", te);
    }, A = (T) => {
      const Y = T.target;
      l("inputChange", Y.value, T);
    }, F = R(!1), K = async () => {
      F.value = !1, await k(""), l("inputChange", "");
    }, ne = () => {
      F.value = !0;
    }, O = async (T) => {
      const Y = (x.value || "").trim();
      if (!Y || e.maxLength && g.value && g.value.length >= e.maxLength)
        return;
      const te = g.value ? [...g.value] : [];
      te.push(Y), await _(te), await k(""), l("tagAdd", Y, T), l("change", te), l("inputChange", "");
    }, Q = () => {
      var T;
      (T = E.value) == null || T.focus();
    }, W = R(!1), _e = () => {
      W.value = !0;
    }, pe = () => {
      W.value = !1;
    }, be = M(() => e.clearable && !w.value && !e.readonly), ce = M(() => !w.value && !e.readonly), ve = je();
    n({
      focus: () => {
        var T;
        (T = E.value) == null || T.focus();
      },
      blur: () => {
        var T;
        (T = E.value) == null || T.blur();
      },
      clear: () => D()
    });
    const re = M(() => !!e.collapseTags && he(e.maxDisplayTags) && e.maxDisplayTags >= 0), J = M(() => g.value ? re.value ? g.value.slice(0, e.maxDisplayTags) : g.value : []), ye = M(() => g.value ? re.value ? g.value.slice(e.maxDisplayTags) : [] : []), me = Le();
    we(
      [
        i,
        d,
        m,
        h,
        v,
        w,
        () => ve,
        me,
        F,
        W
      ],
      () => {
        setTimeout(() => {
          $e();
        });
      }
    );
    const $e = () => {
      const T = Xe(H, L);
      if (!T)
        return;
      const { ctx: Y, width: te, height: fe, canvas: de } = T, He = Ne(), at = gt(
        de,
        He,
        m.value,
        h.value,
        v.value || "medium",
        f.value,
        i.value,
        d.value
      ), Ye = e.status !== "normal" ? b(e.status === "error" ? "danger" : e.status, 6) : (W.value || F.value) && !w.value && !e.readonly ? b("primary", 6) : b("neutral", 10), lt = ft(at, te, fe, He);
      Dl(
        Y,
        te,
        fe,
        lt,
        at,
        it,
        Ye,
        He,
        f.value,
        i.value,
        d.value
      );
      const le = w.value ? b("neutral", 6) : b("neutral", 1);
      ct(Y, Math.round(te / 2), Math.round(fe / 2), le);
    };
    return Re(() => {
      ae(() => {
        $e();
      });
    }), We(H, $e), qe($e), (T, Y) => {
      var te;
      return C(), B("div", {
        class: se(["pixelium px-input-tag", {
          [`px-input-tag__${v.value}`]: !!v.value,
          [`px-input-tag__${h.value}`]: !!h.value,
          "px-input-tag__inner": f.value,
          "px-input-tag__disabled": !!w.value
        }]),
        ref_key: "wrapperRef",
        ref: H,
        onClick: Q,
        onMouseenter: _e,
        onMouseleave: pe
      }, [
        V(ve).prefix ? (C(), B("div", Ds, [
          ee(T.$slots, "prefix")
        ])) : ue("", !0),
        z("div", Os, [
          (C(!0), B(De, null, Nt(J.value, (fe, de) => (C(), Ve(st, {
            key: de,
            size: y.value,
            variant: e.tagVariant,
            theme: e.tagTheme,
            closable: ce.value,
            disabled: w.value,
            color: e.tagColor,
            onClose: (He) => U(de, He)
          }, {
            default: _t(() => [
              ee(T.$slots, "tag", {
                tag: fe,
                index: de
              }, () => [
                Je(Ae(fe), 1)
              ])
            ]),
            _: 2
          }, 1032, ["size", "variant", "theme", "closable", "disabled", "color", "onClose"]))), 128)),
          ye.value.length && re.value ? (C(), B(De, { key: 0 }, [
            e.collapseTagsPopover ? (C(), Ve(Wt, { key: 1 }, {
              content: _t(() => [
                z("div", Ns, [
                  (C(!0), B(De, null, Nt(ye.value, (fe, de) => (C(), Ve(st, {
                    key: de,
                    size: y.value,
                    variant: e.tagVariant,
                    theme: e.tagTheme,
                    closable: ce.value,
                    disabled: w.value,
                    color: e.tagColor,
                    onClose: (He) => U(de + Math.floor(e.maxDisplayTags), He)
                  }, {
                    default: _t(() => [
                      ee(T.$slots, "tag", {
                        tag: fe,
                        index: de + Math.floor(e.maxDisplayTags)
                      }, () => [
                        Je(Ae(fe), 1)
                      ])
                    ]),
                    _: 2
                  }, 1032, ["size", "variant", "theme", "closable", "disabled", "color", "onClose"]))), 128))
                ])
              ]),
              default: _t(() => [
                I(st, {
                  size: y.value,
                  variant: e.tagVariant,
                  theme: e.tagTheme,
                  disabled: w.value,
                  color: e.tagColor
                }, {
                  default: _t(() => [
                    ee(T.$slots, "tag", {
                      tag: `+${ye.value.length}`,
                      index: -1
                    }, () => [
                      Je("+" + Ae(ye.value.length), 1)
                    ])
                  ]),
                  _: 3
                }, 8, ["size", "variant", "theme", "disabled", "color"])
              ]),
              _: 3
            })) : (C(), Ve(st, {
              key: 0,
              size: y.value,
              variant: e.tagVariant,
              theme: e.tagTheme,
              disabled: w.value,
              color: e.tagColor
            }, {
              default: _t(() => [
                ee(T.$slots, "tag", {
                  tag: `+${ye.value.length}`,
                  index: -1
                }, () => [
                  Je("+" + Ae(ye.value.length), 1)
                ])
              ]),
              _: 3
            }, 8, ["size", "variant", "theme", "disabled", "color"]))
          ], 64)) : ue("", !0),
          z("input", {
            class: "px-input-tag-inner",
            value: V(x),
            ref_key: "inputRef",
            ref: E,
            placeholder: V(g) && V(g).length ? "" : e.placeholder,
            disabled: w.value || e.readonly,
            autofocus: t.autofocus,
            onInput: vt(G, ["stop"]),
            onChange: vt(A, ["stop"]),
            onBlur: K,
            onFocus: ne,
            onCompositionstart: Y[0] || (Y[0] = //@ts-ignore
            (...fe) => V(r) && V(r)(...fe)),
            onCompositionend: Y[1] || (Y[1] = //@ts-ignore
            (...fe) => V(s) && V(s)(...fe)),
            onKeydown: jo(O, ["enter"])
          }, null, 40, Fs)
        ]),
        be.value ? (C(), B("div", Gs, [
          W.value && ((te = V(g)) != null && te.length) ? (C(), Ve(V(Ht), {
            key: 0,
            class: "px-input-tag-icon",
            onClick: D
          })) : (C(), B("div", Ws))
        ])) : ue("", !0),
        e.loading ? (C(), B("div", Us, [
          I(V(ot), { class: "px-input-tag-icon px-animation__loading" })
        ])) : ue("", !0),
        V(ve).suffix ? (C(), B("div", js, [
          ee(T.$slots, "suffix")
        ])) : ue("", !0),
        z("canvas", {
          class: "px-input-tag-canvas",
          ref_key: "canvasRef",
          ref: L
        }, null, 512)
      ], 34);
    };
  }
}), qs = 16, Ys = 300, Ks = /* @__PURE__ */ X({
  name: "Tooltip",
  __name: "index",
  props: {
    content: null,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    placement: {
      default: "top"
    },
    trigger: {
      default: "hover"
    },
    offset: {
      default: 8
    },
    variant: {
      default: "dark"
    },
    arrow: {
      type: Boolean,
      default: !0
    },
    disabled: {
      type: Boolean
    },
    zIndex: null,
    root: {
      default: "body"
    }
  },
  emits: ["update:visible", "close", "open"],
  setup(t, {
    emit: n
  }) {
    const o = t, e = M(() => o.visible !== void 0), l = e.value ? o.visible : o.defaultVisible, a = R(Me(l) ? !1 : l), r = S(), s = S(), u = n, f = S(null);
    let c;
    async function i(k, H) {
      c && (c(), c = void 0), await d(k), u("open", H);
    }
    async function d(k, H = !1) {
      ie() && (y == null || y.disconnect(), k.el instanceof HTMLElement ? f.value = k : f.value = null, f.value && f.value.el instanceof HTMLElement && (y == null || y.observe(f.value.el))), e.value && !H ? (u("update:visible", !0), await ae(() => {
      }), a.value = !!o.visible) : a.value = !0;
    }
    async function p(k) {
      if (o.trigger === "click") {
        if (r.value && r.value.content && r.value.content.contains(k.target) || !a.value)
          return;
      } else {
        c && (c(), c = void 0);
        const {
          resolve: H,
          reject: L,
          promise: E
        } = Promise.withResolvers();
        c = L, setTimeout(() => {
          H();
        }, Ys);
        try {
          await E;
        } catch {
          return;
        }
      }
      e.value ? (u("update:visible", !1), await ae(() => {
      }), a.value = !!o.visible) : a.value = !1, u("close", k);
    }
    const m = () => {
      o.trigger !== "click" && c && (c(), c = void 0);
    }, v = (k) => {
      o.trigger !== "click" && p(k);
    }, h = () => {
      ie() && !f.value && s.value && s.value.firstVNode && (y == null || y.disconnect(), f.value = s.value.firstVNode, f.value.el instanceof HTMLElement && (y == null || y.observe(f.value.el)));
    }, w = (k) => {
      k ? (h(), f.value && d(f.value, !0)) : a.value = !1;
    };
    we(() => o.visible, () => {
      w(!!o.visible);
    });
    const y = ie() ? new ResizeObserver(() => {
      g();
    }) : null;
    Re(() => {
      ae(() => {
        a.value && g();
      });
    });
    const g = () => {
      var k;
      h(), ie() && ((k = r.value) == null || k.updateRenderState());
    }, _ = je(), x = (k) => {
      var H;
      return ie() ? ((H = f.value) == null ? void 0 : H.el) instanceof HTMLElement : !1;
    };
    return () => {
      var k;
      return I(De, null, [I(Bo, {
        trigger: o.trigger,
        disabled: o.disabled,
        onClose: p,
        onOpen: i,
        ref: (H) => s.value = H
      }, {
        default: () => {
          var H;
          return [(H = _.default) == null ? void 0 : H.call(_)];
        }
      }), I($o, {
        visible: a.value,
        content: o.content,
        zIndex: o.zIndex,
        variant: o.variant,
        placement: o.placement,
        arrow: o.arrow,
        offset: o.offset,
        borderRadius: qs,
        root: o.root,
        target: x((k = f.value) == null ? void 0 : k.el) ? f.value.el : null,
        onContentMouseenter: m,
        onContentMouseleave: v,
        ref: (H) => r.value = H
      }, {
        content: _.content
      })]);
    };
  }
}), Qs = /* @__PURE__ */ X({
  props: {
    size: {},
    color: {}
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("svg", {
      class: "px-icon-pa",
      style: oe({ color: n.color, fontSize: n.size + "px" }),
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24"
    }, [...e[0] || (e[0] = [
      z("path", {
        fill: "currentColor",
        d: "M11 22h10V8h-2V6h-2v2h-2V6h2V4h-2V2H3v12h2V4h8v6h6v10h-8zm-4-2H5v2H3v-2h2v-2H3v-2h2v2h2v-2h2v2H7zm0 0h2v2H7z"
      }, null, -1)
    ])], 4));
  }
}), Js = { class: "pixelium px-empty" }, Zs = { class: "px-empty-icon-wrapper" }, Ss = { class: "px-empty-description" }, Pn = /* @__PURE__ */ X({
  name: "Empty",
  __name: "index",
  props: {
    description: { default: "No Data" }
  },
  setup(t) {
    const n = t;
    return (o, e) => (C(), B("div", Js, [
      z("div", Zs, [
        ee(o.$slots, "image", {}, () => [
          I(V(Qs), { class: "px-empty-icon" })
        ])
      ]),
      z("div", Ss, [
        ee(o.$slots, "description", {}, () => [
          Je(Ae(n.description), 1)
        ])
      ])
    ]));
  }
}), zs = (t, n, o, e, l, a, r, s, u, f, c) => {
  t.fillStyle = j(r);
  for (let i = 0; i < 4; i++)
    l[i] <= s || (!(i === 1 || i === 2) || u && c || !u) && Fe(
      t,
      e[i][0],
      e[i][1],
      l[i],
      a[i][0],
      a[i][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(e[0][0], 0, e[1][0] - e[0][0] + s, s), e[2][1] + s > e[1][1] && (u && c || !u) && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0],
    o - s,
    e[2][0] - e[3][0] + s,
    s
  ), e[3][1] + s > e[0][1] && !(u && !f) && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s), u && !f && t.fillRect(s / 2, 0, s / 2, o), u && !c && t.fillRect(n - 2 * s - 1, 0, s, o);
}, er = { class: "px-option-list" }, tr = ["onClick"], nr = ["onClick"], or = {
  key: 2,
  class: "px-option-list-item-group"
}, ar = { class: "px-option-list-item-group-label" }, lr = ["onClick"], sr = ["onClick"], Po = /* @__PURE__ */ X({
  name: "OptionList",
  __name: "index",
  props: {
    options: { default: () => [] },
    activeValues: { default: () => [] }
  },
  emits: ["select"],
  setup(t, { emit: n }) {
    const o = t, e = n, l = (u, f) => {
      e("select", u, u, f);
    }, a = (u, f) => {
      u.disabled || e("select", u.value, u, f);
    }, r = (u) => Pe(u) ? u : "type" in u && u.type === Ct ? u.key : u.label, s = (u) => o.activeValues.length ? Pe(u) ? o.activeValues.includes(u) : o.activeValues.includes(u.value) : !1;
    return (u, f) => (C(), B("ul", er, [
      (C(!0), B(De, null, Nt(o.options, (c) => (C(), B(De, {
        key: r(c)
      }, [
        V(Pe)(c) ? (C(), B("li", {
          key: 0,
          class: se(["px-option-list-item", {
            "px-option-list-item__active": s(c)
          }]),
          onClick: (i) => l(c, i)
        }, [
          ee(u.$slots, "option", { option: c }, () => [
            Je(Ae(c), 1)
          ])
        ], 10, tr)) : V(jt)(c) && !("type" in c && c.type === V(Ct)) ? (C(), B("li", {
          key: 1,
          class: se(["px-option-list-item", {
            "px-option-list-item__disabled": c.disabled,
            "px-option-list-item__active": s(c)
          }]),
          onClick: (i) => a(c, i)
        }, [
          ee(u.$slots, "option", { option: c }, () => [
            Je(Ae(c.label), 1)
          ])
        ], 10, nr)) : (C(), B("li", or, [
          z("div", ar, [
            ee(u.$slots, "group-label", { option: c }, () => [
              Je(Ae(c.label), 1)
            ])
          ]),
          (C(!0), B(De, null, Nt(c.children, (i) => (C(), B(De, {
            key: r(i)
          }, [
            V(Pe)(i) ? (C(), B("li", {
              key: 0,
              class: se(["px-option-list-item", {
                "px-option-list-item__active": s(i)
              }]),
              onClick: (d) => l(i, d)
            }, [
              ee(u.$slots, "option", { option: i }, () => [
                Je(Ae(i), 1)
              ])
            ], 10, lr)) : (C(), B("li", {
              key: 1,
              class: se(["px-option-list-item", {
                "px-option-list-item__disabled": i.disabled,
                "px-option-list-item__active": s(i)
              }]),
              onClick: (d) => a(i, d)
            }, [
              ee(u.$slots, "option", { option: i }, () => [
                Je(Ae(i.label), 1)
              ])
            ], 10, sr))
          ], 64))), 128))
        ]))
      ], 64))), 128))
    ]));
  }
}), rr = /* @__PURE__ */ X({
  name: "AutoComplete",
  __name: "index",
  props: {
    modelValue: null,
    defaultValue: null,
    options: {
      default: () => []
    },
    placeholder: null,
    disabled: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    clearable: {
      type: Boolean,
      default: !1
    },
    loading: {
      type: Boolean,
      default: !1
    },
    showPopoverEmpty: {
      type: Boolean,
      default: !1
    },
    shouldShowPopover: {
      type: Function
    },
    filter: {
      type: Function
    },
    append: {
      type: Boolean,
      default: !1
    },
    size: {
      default: "medium"
    },
    shape: {
      default: "default"
    },
    borderRadius: null,
    status: {
      default: "normal"
    },
    autofocus: {
      type: Boolean
    }
  },
  emits: ["input", "update:modelValue", "change", "clear", "blur", "focus", "select"],
  setup(t, {
    expose: n,
    emit: o
  }) {
    var $e;
    const e = Mn(), l = Ne(), a = t, r = o, [s, u, f] = It({
      afterComposition: (q) => {
        ae(() => {
          D(q);
        });
      }
    }), c = et(), i = R((($e = c == null ? void 0 : c.parent) == null ? void 0 : $e.type) === wt), [d, p, m] = i.value ? ut(yt) : [R(0), R(!1), R(!1)], v = Ze(bt), h = M(() => i.value && v ? v.borderRadius : a.borderRadius), w = M(() => i.value && v ? v.size : a.size), y = M(() => i.value && v ? v.shape : a.shape), g = M(() => i.value && v && v.disabled || a.disabled), [_, x] = mt("modelValue", a, r, {
      defaultField: "defaultValue",
      transform: (q) => q || ""
    }), k = S(null), H = S(null), L = S(null), E = async () => {
      if (await ae(), a.shouldShowPopover) {
        re.value = !!a.shouldShowPopover(_.value || "", ve.value);
        return;
      }
      _.value && (!a.showPopoverEmpty && ve.value.length || a.showPopoverEmpty) ? re.value = !0 : re.value = !1;
    }, G = async () => {
      re.value = !1;
    }, D = async (q) => {
      q.stopPropagation();
      const Y = q.target.value;
      _.value = Y, !s.value && (r("input", Y, q), await x(Y), E());
    }, U = async () => {
      await x(""), r("change", ""), r("clear", "");
    }, A = (q) => {
      q.stopPropagation();
      const T = q.target;
      r("change", T.value, q);
    }, F = R(!1), K = () => {
      F.value = !1;
    }, ne = () => {
      F.value = !0;
    }, O = () => {
      var q;
      (q = L.value) == null || q.focus();
    }, Q = R(!1), W = () => {
      Q.value = !0;
    }, _e = () => {
      Q.value = !1;
    }, pe = M(() => a.clearable && !g.value && !a.readonly), be = async (q, T, Y) => {
      const te = a.append ? _.value + q : q;
      await x(te), G(), r("select", te, T, Y);
    }, ce = je(), ve = M(() => a.filter ? a.filter(_.value || "", a.options || []) : !_.value || !_.value.trim() ? [] : Hn(_.value, a.options || []));
    n({
      focus: () => {
        var q;
        (q = L.value) == null || q.focus();
      },
      blur: () => {
        var q;
        (q = L.value) == null || q.blur();
      },
      clear: () => U(),
      select: () => {
        var q;
        (q = L.value) == null || q.select();
      }
    });
    const re = R(!1), J = (q) => {
      q || (re.value = q);
    }, ye = Le();
    we([p, m, h, y, w, g, () => ce, ye, F, Q], () => {
      setTimeout(() => {
        me();
      });
    });
    const me = () => {
      const q = Xe(k, H);
      if (!q)
        return;
      const {
        ctx: T,
        width: Y,
        height: te,
        canvas: fe
      } = q, de = Ne(), He = gt(fe, de, h.value, y.value, w.value || "medium", i.value, p.value, m.value), at = a.status !== "normal" ? b(a.status === "error" ? "danger" : a.status, 6) : (Q.value || F.value) && !g.value && !a.readonly ? b("primary", 6) : b("neutral", 10), Ye = ft(He, Y, te, de);
      zs(T, Y, te, Ye, He, it, at, de, i.value, p.value, m.value);
      const $ = g.value ? b("neutral", 6) : b("neutral", 1);
      ct(T, Math.round(Y / 2), Math.round(te / 2), $);
    };
    return Re(() => {
      ae(() => {
        me();
      });
    }), We(k, me), qe(me), () => {
      const q = I(De, null, [ce.prefix && I("div", {
        class: "px-auto-complete-prefix-wrapper"
      }, [ce.prefix()]), I("input", {
        ref: L,
        class: "px-auto-complete-inner",
        value: _.value,
        placeholder: a.placeholder,
        disabled: g.value || a.readonly,
        autofocus: a.autofocus,
        onInput: D,
        onChange: A,
        onBlur: K,
        onFocus: ne,
        onCompositionstart: u,
        onCompositionend: f
      }, null), pe.value && I("div", {
        class: "px-auto-complete-close-wrapper"
      }, [Q.value && _.value ? I(Ht, {
        class: "px-auto-complete-icon",
        onClick: U
      }, null) : I("div", {
        class: "px-auto-complete-icon-placeholder"
      }, null)]), a.loading && I("div", {
        class: "px-auto-complete-loading-wrapper"
      }, [I(ot, {
        class: "px-auto-complete-icon px-animation__loading"
      }, null)]), ce.suffix && I("div", {
        class: "px-auto-complete-suffix-wrapper"
      }, [ce.suffix()]), I("canvas", {
        ref: H,
        class: "px-auto-complete-canvas"
      }, null)]), T = {}, Y = c == null ? void 0 : c.vnode.scopeId, te = c == null ? void 0 : c.vnode.scopeId;
      return Y && (T[Y] = ""), te && (T[te] = ""), I(Wt, {
        placement: "bottom",
        offset: 0,
        "width-equal": !0,
        arrow: !1,
        visible: re.value,
        "onUpdate:visible": J,
        trigger: "click",
        contentStyle: {
          padding: `${l}px`
        }
      }, {
        default: () => no("div", {
          ref: k,
          class: ["pixelium px-auto-complete", w.value && `px-auto-complete__${w.value}`, y.value && `px-auto-complete__${y.value}`, {
            "px-auto-complete__inner": i.value
          }, {
            "px-auto-complete__disabled": g.value
          }],
          onClick: O,
          onMouseenter: W,
          onMouseleave: _e,
          ...T,
          ...e
        }, [q]),
        content: () => ve.value.length ? I(Po, {
          options: ve.value,
          onSelect: be
        }, {
          "group-label": ({
            option: de
          }) => ce["group-label"] ? ce["group-label"]({
            option: de
          }) : de.label,
          option: ({
            option: de
          }) => ce.option ? ce.option({
            option: de
          }) : Pe(de) ? de : de.label
        }) : I("div", {
          class: "px-auto-complete-empty"
        }, [I(Pn, null, null)])
      });
    };
  }
}), Io = /* @__PURE__ */ X({
  name: "Mask",
  __name: "index",
  props: {
    color: null,
    step: { default: 1 },
    lineWidth: { default: 2 },
    grid: { type: Boolean, default: !0 },
    zIndex: { default: ao }
  },
  setup(t) {
    const n = Le(), o = t, e = S(null), l = S(null), a = () => {
      const u = b("neutral", 8);
      return u.a = Math.floor(255 * 0.5), j(u);
    }, r = R(a()), s = () => {
      if (!o.grid)
        return;
      const u = Xe(l, e);
      if (!u)
        return;
      const { ctx: f, width: c, height: i } = u, d = o.lineWidth;
      f.clearRect(0, 0, c, i), f.strokeStyle = o.color || r.value, f.lineWidth = d;
      const p = Math.max(1, o.step);
      for (let m = 0; m <= c; m += p + d)
        f.beginPath(), f.moveTo(m, 0), f.lineTo(m, i), f.stroke();
      for (let m = 0; m <= i; m += p + d)
        f.beginPath(), f.moveTo(0, m), f.lineTo(c, m), f.stroke();
    };
    return Re(() => {
      ae(() => {
        s();
      });
    }), We(l, s), qe(() => {
      s(), r.value = a();
    }), we(
      [
        n,
        r,
        () => o.grid,
        () => o.color,
        () => o.step,
        () => o.lineWidth
      ],
      () => {
        r.value = a(), s();
      }
    ), (u, f) => (C(), B("div", {
      class: "pixelium px-mask",
      style: oe({
        zIndex: o.zIndex,
        backgroundColor: o.grid ? void 0 : o.color || r.value
      }),
      ref_key: "wrapperRef",
      ref: l
    }, [
      o.grid ? (C(), B("canvas", {
        key: 0,
        ref_key: "canvasRef",
        ref: e,
        class: "px-mask-canvas"
      }, null, 512)) : ue("", !0)
    ], 4));
  }
}), ur = { class: "px-spin-content" }, ir = /* @__PURE__ */ X({
  name: "Spin",
  __name: "index",
  props: {
    loading: { type: Boolean, default: void 0 },
    size: { default: "medium" },
    maskColor: null,
    maskStep: { default: 1 },
    maskLineWidth: { default: 2 },
    maskGrid: { type: Boolean, default: !0 },
    zIndex: { default: ao }
  },
  setup(t) {
    const n = t, o = je(), e = M(() => he(n.size) ? `${n.size}px` : void 0), l = M(() => o.default ? !!n.loading : n.loading !== !1);
    return (a, r) => (C(), B("div", {
      class: se(["pixelium px-spin", {
        [`px-spin__${n.size}`]: V(Pe)(n.size)
      }]),
      style: oe({
        minWidth: e.value,
        minHeight: e.value
      })
    }, [
      ee(a.$slots, "default"),
      l.value ? (C(), B("div", {
        key: 0,
        class: "px-spin-cover",
        style: oe({
          zIndex: n.zIndex
        })
      }, [
        V(o).default ? (C(), Ve(Io, {
          key: 0,
          "z-index": 0,
          color: n.maskColor,
          step: n.maskStep,
          "line-width": n.maskLineWidth,
          grid: n.maskGrid
        }, null, 8, ["color", "step", "line-width", "grid"])) : ue("", !0),
        z("div", ur, [
          z("div", {
            class: se(["px-spin-icon-wrapper", {
              "px-spin-icon-wrapper__last": !V(o).description,
              [`px-spin-icon-wrapper__${n.size}`]: V(Pe)(n.size)
            }]),
            style: oe({
              fontSize: e.value
            })
          }, [
            ee(a.$slots, "icon", {}, () => [
              I(V(ot), {
                class: "px-spin-icon px-animation__loading",
                style: oe({
                  width: e.value,
                  height: e.value
                })
              }, null, 8, ["style"])
            ])
          ], 6),
          ee(a.$slots, "description")
        ])
      ], 4)) : ue("", !0)
    ], 6));
  }
}), cr = (t, n, o, e, l, a, r, s, u, f, c) => {
  t.fillStyle = j(r);
  for (let i = 0; i < 4; i++)
    l[i] <= s || (!(i === 1 || i === 2) || u && c || !u) && Fe(
      t,
      e[i][0],
      e[i][1],
      l[i],
      a[i][0],
      a[i][1],
      s
    );
  e[1][0] + s > e[0][0] && t.fillRect(e[0][0], 0, e[1][0] - e[0][0] + s, s), e[2][1] + s > e[1][1] && (u && c || !u) && t.fillRect(
    n - s,
    e[1][1],
    s,
    e[2][1] - e[1][1] + s
  ), e[3][0] < e[2][0] + s && t.fillRect(
    e[3][0],
    o - s,
    e[2][0] - e[3][0] + s,
    s
  ), e[3][1] + s > e[0][1] && !(u && !f) && t.fillRect(0, e[0][1], s, e[3][1] - e[0][1] + s), u && !f && t.fillRect(s / 2, 0, s / 2, o), u && !c && t.fillRect(n - 2 * s - 1, 0, s, o);
}, Sn = 250, fr = /* @__PURE__ */ X({
  name: "Select",
  __name: "index",
  props: {
    modelValue: null,
    defaultValue: null,
    options: {
      default: () => []
    },
    placeholder: null,
    disabled: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    clearable: {
      type: Boolean,
      default: !1
    },
    multiple: {
      type: Boolean,
      default: !1
    },
    loading: {
      type: Boolean,
      default: !1
    },
    inputValue: null,
    defaultInputValue: null,
    filterable: {
      type: Boolean,
      default: !1
    },
    shouldShowPopover: {
      type: Function
    },
    filter: {
      type: Function
    },
    creatable: {
      type: Boolean
    },
    collapseTags: {
      type: Boolean,
      default: !1
    },
    maxDisplayTags: null,
    collapseTagsPopover: {
      type: Boolean,
      default: !0
    },
    tagTheme: {
      default: "info"
    },
    tagVariant: {
      default: "plain"
    },
    tagColor: null,
    size: {
      default: "medium"
    },
    shape: {
      default: "default"
    },
    borderRadius: null,
    status: {
      default: "normal"
    }
  },
  emits: ["input", "update:modelValue", "update:inputValue", "change", "inputChange", "clear", "blur", "focus", "select", "tagClose"],
  setup(t, {
    expose: n,
    emit: o
  }) {
    var kt;
    const e = Mn(), l = Ne(), a = t, r = o, [s, u, f] = It({
      afterComposition: (P) => {
        ae(() => {
          Q(P);
        });
      }
    }), c = et(), i = R(((kt = c == null ? void 0 : c.parent) == null ? void 0 : kt.type) === wt), [d, p, m] = i.value ? ut(yt) : [R(0), R(!1), R(!1)], v = Ze(bt), h = M(() => i.value && v ? v.borderRadius : a.borderRadius), w = M(() => i.value && v ? v.size : a.size), y = M(() => i.value && v ? v.shape : a.shape), g = M(() => i.value && v && v.disabled || a.disabled), _ = (P) => Qo(P) || Jo(P) || a.multiple && rt(P) && P.length === 0, [x, k] = mt("modelValue", a, r, {
      defaultField: "defaultValue",
      transform: (P) => a.multiple ? Me(P) ? void 0 : rt(P) ? [...P] : [P] : P
    }), [H, L] = mt("inputValue", a, r, {
      defaultField: "defaultInputValue",
      transform: (P) => P || ""
    }), E = M(() => {
      if (!a.multiple)
        return [];
      if (!a.options.length)
        return [];
      if (_(x.value))
        return [];
      const P = /* @__PURE__ */ new Map();
      return a.options.forEach((N) => {
        if (Pe(N))
          P.set(N, N);
        else {
          if ("type" in N && N.type === Ct)
            return N.children.some((Z) => {
              Pe(Z) ? P.set(Z, Z) : P.set(Z.value, Z.label);
            });
          P.set(N.value, N.label);
        }
      }), x.value.map((N) => P.has(N) ? P.get(N) : String(N));
    }), G = M(() => {
      if (a.multiple || !a.options.length || _(x.value))
        return "";
      let P = String(x.value);
      return a.options.some((N) => Pe(N) ? x.value === N : "type" in N && N.type === Ct ? N.children.some((Z) => Pe(Z) ? x.value === Z : Z.value === x.value ? (P = Z.label, !0) : !1) : N.value === x.value ? (P = N.label, !0) : !1), P;
    }), D = S(null), U = S(null), A = S(null), F = S(null), K = S(null);
    we(() => a.multiple, (P, N) => {
      k(P && !N ? [x.value] : x.value[0] || null);
    });
    const ne = async () => {
      if (await ae(), a.shouldShowPopover) {
        te.value = !!a.shouldShowPopover(H.value || "", Y.value);
        return;
      }
      te.value = !0;
    }, O = async () => {
      te.value = !1;
    }, Q = async (P) => {
      P.stopPropagation();
      const Z = P.target.value;
      H.value = Z, !s.value && (r("input", Z, P), L(Z), await r("update:inputValue", Z), ne());
    }, W = async () => {
      await new Promise((N) => {
        setTimeout(() => {
          N();
        });
      });
      const P = a.multiple ? [] : null;
      await L(""), await k(P), r("change", P), r("clear", P), r("inputChange", "");
    }, _e = (P) => {
      P.stopPropagation();
      const N = P.target;
      r("inputChange", N.value, P);
    }, pe = R(!1), be = () => {
      pe.value = !0, ae(() => {
        if (A.value && a.filterable) {
          if (A.value.focus(), a.multiple)
            return;
          const P = _(x.value) ? H.value || "" : G.value;
          L(P);
        }
      }), ne(), r("focus");
    }, ce = (P) => {
      var Z;
      if (g.value || a.readonly)
        return;
      const N = P.target;
      (N instanceof HTMLElement || N instanceof SVGElement) && (Z = K.value) != null && Z.$el.contains(N) || be();
    }, ve = async () => {
      var P;
      pe.value = !1, te.value = !1, (P = A.value) == null || P.blur(), setTimeout(async () => {
        await L(""), r("inputChange", "");
      }, Sn), r("blur");
    };
    To([D, () => {
      var P, N;
      return (N = (P = F.value) == null ? void 0 : P.triggerContent) == null ? void 0 : N.content;
    }], ve);
    const re = R(!1), J = () => {
      re.value = !0;
    }, ye = () => {
      re.value = !1;
    }, me = M(() => a.clearable && !g.value && !a.readonly), $e = (P) => {
      if (a.multiple)
        if (rt(x.value)) {
          const N = [...x.value], Z = N.findIndex((Be) => Be === P);
          return Z === -1 ? N.push(P) : N.splice(Z, 1), N;
        } else
          return [P];
      else
        return P;
    }, q = async (P, N, Z) => {
      await new Promise((ge) => {
        setTimeout(() => {
          ge();
        });
      });
      const Be = $e(P), Ee = "";
      await k(Be), a.multiple || (pe.value = !1, O(), r("select", Be, N, Z), setTimeout(async () => {
        await L(Ee);
      }, Sn));
    }, T = je(), Y = M(() => {
      const P = a.options || [];
      if (!a.filterable)
        return P;
      let N = [];
      return a.filter ? N = a.filter(H.value || "", P) : N = Hn(H.value || "", P), a.multiple && (_(x.value) || x.value.forEach((Z) => {
        const Be = zt(Z, N), Ee = zt(Z, P);
        if (!Be.length)
          if (!Ee.length)
            N.push(Z);
          else if (Ee.length === 1)
            N.push(Ee[0]);
          else {
            const ge = Ee[1], Ke = N.findIndex((Oe) => jt(Oe) && "type" in Oe && Oe.type === Ct && Oe.key === ge.key);
            Ke ? N[Ke].children.push(Ee[0]) : N.push({
              ...ge,
              children: [Ee[0]]
            });
          }
      })), a.creatable && H.value && (zt(H.value, N, !0).length || N.push(H.value)), N;
    });
    n({
      focus: be,
      blur: ve,
      clear: () => W()
    });
    const te = R(!1), fe = (P) => {
      P || (te.value = P);
    }, de = M(() => _(x.value) && (!a.multiple && !G.value || a.multiple)), He = M(() => w.value === "small" ? "small" : "medium"), at = M(() => !g.value && !a.readonly), Ye = async (P, N) => {
      const Z = [...x.value], Be = Z.findIndex((Ee) => Ee === P);
      Be !== -1 && (Z.splice(Be, 1), await k(Z), r("tagClose", P, N), r("change", Z));
    }, lt = M(() => !!a.collapseTags && he(a.maxDisplayTags) && a.maxDisplayTags >= 0), $ = M(() => a.multiple ? a.options.length ? Me(x.value) ? [] : lt.value ? x.value.slice(0, a.maxDisplayTags) : x.value : [] : []), le = M(() => a.multiple ? a.options.length ? Me(x.value) ? [] : lt.value ? x.value.slice(a.maxDisplayTags) : [] : [] : []), Ce = Le();
    we([p, m, h, y, w, g, () => T, Ce, pe, re], () => {
      setTimeout(() => {
        Te();
      });
    });
    const Te = () => {
      const P = Xe(D, U);
      if (!P)
        return;
      const {
        ctx: N,
        width: Z,
        height: Be,
        canvas: Ee
      } = P, ge = Ne(), Ke = gt(Ee, ge, h.value, y.value, w.value || "medium", i.value, p.value, m.value), Oe = a.status !== "normal" ? b(a.status === "error" ? "danger" : a.status, 6) : (re.value || pe.value) && !g.value && !a.readonly ? b("primary", 6) : b("neutral", 10), Lo = ft(Ke, Z, Be, ge);
      cr(N, Z, Be, Lo, Ke, it, Oe, ge, i.value, p.value, m.value);
      const Eo = g.value ? b("neutral", 6) : b("neutral", 1);
      ct(N, Math.round(Z / 2), Math.round(Be / 2), Eo);
    };
    Re(() => {
      ae(() => {
        Te();
      });
    }), We(D, Te), qe(Te);
    const Qt = (P) => {
      P.stopPropagation();
    };
    return () => {
      const P = I(De, null, [T.prefix && I("div", {
        class: "px-select-prefix-wrapper"
      }, [T.prefix()]), I("div", {
        class: "px-select-content"
      }, [a.multiple && $.value.map((ge, Ke) => I(st, {
        key: ge,
        size: He.value,
        variant: a.tagVariant,
        theme: a.tagTheme,
        closable: at.value,
        disabled: g.value,
        color: a.tagColor,
        onClose: (Oe) => Ye(ge, Oe)
      }, {
        default: () => T.tag ? T.tag({
          value: ge,
          label: E.value[Ke],
          index: Ke
        }) : E.value[Ke]
      })), a.multiple && !!le.value.length && lt.value && I(De, null, [a.collapseTagsPopover ? I(Wt, null, {
        default: () => I(st, {
          size: He.value,
          variant: a.tagVariant,
          theme: a.tagTheme,
          disabled: g.value,
          color: a.tagColor
        }, {
          default: () => T.tag ? T.tag({
            value: null,
            label: `+${le.value.length}`,
            index: -1
          }) : `+${le.value.length}`
        }),
        content: () => I("div", {
          class: "px-input-tag-content"
        }, [le.value.map((ge, Ke) => I(st, {
          key: ge,
          size: He.value,
          variant: a.tagVariant,
          theme: a.tagTheme,
          disabled: g.value,
          color: a.tagColor,
          closable: at.value,
          onClose: (Oe) => Ye(ge, Oe)
        }, {
          default: () => {
            const Oe = Ke + Math.floor(a.maxDisplayTags);
            return T.tag ? T.tag({
              value: ge,
              label: E.value[Oe],
              index: Oe
            }) : E.value[Oe];
          }
        }))])
      }) : I(st, {
        size: He.value,
        variant: a.tagVariant,
        theme: a.tagTheme,
        disabled: g.value,
        color: a.tagColor
      }, {
        default: () => T.tag ? T.tag({
          value: null,
          label: `+${le.value.length}`,
          index: -1
        }) : `+${le.value.length}`
      })]), Zt(I("input", {
        ref: A,
        class: "px-select-inner",
        value: H.value,
        disabled: g.value || a.readonly,
        onInput: Q,
        onChange: _e,
        onFocus: Qt,
        onBlur: Qt,
        onCompositionstart: u,
        onCompositionend: f,
        placeholder: de.value ? a.placeholder : ""
      }, null), [[St, a.filterable && pe.value]]), Zt(I("div", {
        class: {
          "px-select-placeholder": !0
        }
      }, [a.placeholder]), [[St, de.value && (!a.filterable || !pe.value)]]), !a.multiple && Zt(I("div", {
        class: {
          "px-select-label": !0,
          "px-select-label__disabled": g.value
        }
      }, [G.value]), [[St, !de.value && (!a.filterable || !pe.value)]])]), me.value && I("div", {
        class: "px-select-close-wrapper"
      }, [re.value && !_(x.value) ? I(Ht, {
        class: "px-select-icon",
        onClick: W,
        ref: (ge) => {
          K.value = ge;
        }
      }, null) : I("div", {
        class: "px-select-icon-placeholder"
      }, null)]), a.loading && I("div", {
        class: "px-select-loading-wrapper"
      }, [I(ot, {
        class: "px-select-icon px-animation__loading"
      }, null)]), T.suffix && I("div", {
        class: "px-select-suffix-wrapper"
      }, [T.suffix()]), I("canvas", {
        ref: U,
        class: "px-select-canvas"
      }, null)]), N = {}, Z = c == null ? void 0 : c.vnode.scopeId, Be = c == null ? void 0 : c.vnode.scopeId;
      return Z && (N[Z] = ""), Be && (N[Be] = ""), I(Wt, {
        placement: "bottom",
        offset: 0,
        "width-equal": !0,
        arrow: !1,
        visible: te.value,
        "onUpdate:visible": fe,
        trigger: "click",
        contentStyle: {
          padding: `${l}px`
        },
        ref: F
      }, {
        default: () => no("div", {
          ref: D,
          class: ["pixelium px-select", w.value && `px-select__${w.value}`, y.value && `px-select__${y.value}`, {
            "px-select__inner": i.value
          }, {
            "px-select__disabled": g.value
          }],
          onClick: ce,
          onMouseenter: J,
          onMouseleave: ye,
          ...N,
          ...e
        }, [P]),
        content: () => Y.value.length ? I(Po, {
          options: Y.value,
          onSelect: q,
          activeValues: a.multiple ? x.value : [x.value]
        }, {
          "group-label": ({
            option: ge
          }) => T["group-label"] ? T["group-label"]({
            option: ge
          }) : ge.label,
          option: ({
            option: ge
          }) => T.option ? T.option({
            option: ge
          }) : Pe(ge) ? ge : ge.label
        }) : I("div", {
          class: "px-select-empty"
        }, [I(Pn, null, null)])
      });
    };
  }
}), dr = [
  ma,
  co,
  ga,
  Ha,
  vo,
  Ta,
  Ba,
  Oa,
  mo,
  Na,
  ho,
  Ga,
  Wa,
  Ua,
  ja,
  Ya,
  ll,
  pl,
  Vl,
  wt,
  Al,
  st,
  Xs,
  Ks,
  Wt,
  Pn,
  rr,
  Io,
  ir,
  fr
], pr = "Px", vr = (t, n = { prefix: pr }) => {
  dr.forEach((o) => {
    o.name && t.component(n.prefix + o.name, o);
  }), n.attachToApp !== !1 && (t.config.globalProperties.PixeliumVue = {
    message: tn,
    useThemeMode: qa
  }), n.attachToWindow !== !1 && ie() && (window.$message = tn);
}, br = {
  install: vr
};
export {
  Wa as Aside,
  rr as AutoComplete,
  ma as Button,
  co as ButtonGroup,
  Ta as Col,
  ho as Container,
  Ba as Divider,
  Pn as Empty,
  ja as Footer,
  mo as Grid,
  Na as GridItem,
  Ua as Header,
  Ya as Icon,
  ll as Input,
  wt as InputGroup,
  Al as InputGroupLabel,
  pl as InputNumber,
  Xs as InputTag,
  ga as Link,
  Ga as Main,
  Io as Mask,
  tn as Message,
  Ha as MessageBox,
  Wt as Popover,
  vo as Row,
  fr as Select,
  Oa as Space,
  ir as Spin,
  st as Tag,
  Vl as Textarea,
  Ks as Tooltip,
  br as default,
  vr as install,
  yr as setThemeColor,
  qa as useThemeMode
};
